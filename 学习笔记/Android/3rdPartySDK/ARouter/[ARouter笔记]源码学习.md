## 整体框架

### 按工程框架
![Image](https://yqfile.alicdn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png)

如图，分成三个模块：
#### Compiler

其内部有三个注解处理器： Route Processor(处理路径路由)，Interceptor Processor(用于处理拦截器相关的信息)以及Autowire Processor(处理跳转目标对象中自动绑定的变量)；该SDK是编译apk时运行的，负责根据注解自动生成相应的代码；

#### API

该SDK是用户在运行期间用的；主要分四层： Launcher、Frossard、Core(SDK的内部实现)、Logistics Center; 

Launcher：主要是ARouter实例的实现和各种对外提供链式调用的API。
Service：将一定的功能和组件封装成接口，并对外提供能力，如拦截，降级，替换跳转路径等；
CallBack： 是某些服务的回调，业务根据回调进行相应的处理，如跳转失败时候的处理等。
Template： 是模板，主要用于在编译期执行的SDK，这个SDK会在编译期生成一些映射文件，而这些映射文件会按照Template组件中提供的模板来生成，这样按照一定的规则和约束生成映射文件也方便Route在运行的时候进行读取。

Ware House：主要存储了ARouter在运行期间加载的一些配置文件以及映射关系，处理框架运行过程中，缓存，线程，日志，异常等相关的操作;
Thread： 提供了线程池，因为存在多个拦截器的时候以及跳转过程中都是需要异步执行的； 
Class工具： 用于解决不同类型APK的兼容问题的。

Logistics Center 从名字上翻译就是物流中心，整个SDK的流转以及内部调用最终都会下沉到这一层；主要是路由机制的初始化，和跳转过程处理参数相关流程; 

#### Annotation
该模块没在上面框架图中，但它会编译进API模块中；该Annotation主要定义注解(@Autowired, @Interceptor,@Route); 

### 按功能组件分框架
![Image1](https://yqfile.alicdn.com/e4d3ec6020479ef2043cfd7e10cfaf33254ac309.png)

其实ARouter在设计上使用了三种思想：Bootstrapping、Extensibility以及Simple & Enough。首先，ARouter的组件是自举的，这个概念借鉴了编程中的自举；除此之外ARouter组件还具有良好的扩展性，因为像Route这样的东西是整个APK的基础组件，不可能经常变更，也不可能经常升级，所以应该具有良好的扩展性，而不需要通过经常升级来解决问题；而ARouter最重要的宗旨就是简单并且够用，ARouter不会有非常复杂的使用方式和调用方式，但是功能却是非常全面的。

可以从图中看出ARouter的最外面一层就是Route，这一层是整个框架的基础，而这一层也应该非常稳定，几乎不会发生变更。再往上一层就是Service层，这一层是依赖于底层的Route构建起来的，也就是说Service层是通过Route才实现的功能。再往上一层就是Interceptor层，拦截器层则是通过Service的机制实现的，拦截器和Service都会作用于整个路由的过程中，所以说组件之间是自举的，因为Service和Interceptor在没有Route时是不会出现的，它们都是由Route层构建起来的，反过来又会作用于Route层，这也是ARouter的可扩展性的表现，后续的扩展都会基于Service层来实现。

## Compiler模块源码学习

Compiler模块译apk时运行的，负责根据注解自动生成相应的代码；下面为Compiler模块注解处理器类图：

图（略）

### @Route注解

下面我们以ARouterUrlActivity为例子，该Activity是跳转目标页面，并自行为其变量赋值；

```java
// 为每一个参数声明一个字段，并使用 @Autowired 标注
@Route(path = "/activity/UrlActivity")
public class ARouterUrlActivity extends Activity {
    @Autowired
    public String mName;
    @Autowired
    int age;
    @Autowired(name = "girl") // 通过name来映射URL中的不同参数
    boolean isBoy;

    /**
     * 如果需要传递自定义对象，新建一个类（并非自定义对象类）,
     * 然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)
     */
    @Autowired
    TestObj obj;    // 支持解析自定义对象，URL中使用json传递

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ARouter.getInstance().inject(this);
    }
```

针对该Activity中的@Route注解,@Autowired注解，注解处理器自动生成的代码如下：

```java
package com.alibaba.android.arouter.routes;

...

/**
 * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */
public class ARouter$$Group$$activity implements IRouteGroup {
  @Override
  public void loadInto(Map<String, RouteMeta> atlas) {
    atlas.put("/activity/ARouterUrlActivity", RouteMeta.build(RouteType.ACTIVITY, ARouterUrlActivity.class, "/activity/arouterurlactivity", "activity", new java.util.HashMap<String, Integer>(){{put("obj", 11); put("mName", 8); put("girl", 0); put("age", 3); }}, -1, -2147483648));
    atlas.put("/activity/InterceptTestingActivity", RouteMeta.build(RouteType.ACTIVITY, InterceptTestingActivity.class, "/activity/intercepttestingactivity", "activity", null, -1, 3));
    atlas.put("/activity/normalJumpActivity", RouteMeta.build(RouteType.ACTIVITY, ARouterNormalJumpActivity.class, "/activity/normaljumpactivity", "activity", null, -1, -2147483648));
  }
}
```


接下来看RouteProcessor是如何生成的；在RouteProcessor类中两个重要的集合, 分别记录root和group的数据，这些数据以树结构保存；
在这里要理清一个概念： 在每一个模块中，都有一个root根， root点是根结点；而挂root下面是group(组)，而group下面挂的是各自目标页面；
```java
    private Map<String, Set<RouteMeta>> groupMap = new HashMap<>(); // ModuleName and routeMeta.
    private Map<String, String> rootMap = new TreeMap<>();  // Map of root metas, used for generate class file in order.
```

所以在处理除了生成上面ARouter$$Group$$activity文件外，所处理的group需要挂在root中，以便一层一层查找，因此要生成相应的类文件。
这里就是arouterlib2组件中，所以group注册；
```java
package com.alibaba.android.arouter.routes;

/**
 * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */
public class ARouter$$Root$$arouterlib2 implements IRouteRoot {
  @Override
  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {
    routes.put("activity", ARouter$$Group$$activity.class);
    routes.put("degrade", ARouter$$Group$$degrade.class);
    routes.put("service", ARouter$$Group$$service.class);
    routes.put("xxx", ARouter$$Group$$xxx.class);
  }
}
```

1. 首先获取使用@Route注解标注的元素,把获取的元素放入parseRoutes方法进行解析 ：

```java

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (CollectionUtils.isNotEmpty(annotations)) {
            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);
            try {
                logger.info(">>> Found routes, start... <<<");
                this.parseRoutes(routeElements);

            } catch (Exception e) {
                logger.error(e);
            }
            return true;
        }
        return false;
    }
```

2. 生成loadInto()方法（暂时无具体实现）， 
需要注意的生成代码的工具是使用 javapoet库来生成的，学习 javapoet库的使用请参考 ；
```java
            //把rootMap进行清空；
            rootMap.clear();

            //获取相应类型元素
            TypeMirror type_Activity = elementUtils.getTypeElement(ACTIVITY).asType();

            // Interface of ARouter
            TypeElement type_IRouteGroup = elementUtils.getTypeElement(IROUTE_GROUP);
            ClassName routeMetaCn = ClassName.get(RouteMeta.class);
            ClassName routeTypeCn = ClassName.get(RouteType.class);

            //创建输入类型
            /*
               Build input type, format as :
               ```Map<String, Class<? extends IRouteGroup>>```
             */
            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(
                    ClassName.get(Map.class),
                    ClassName.get(String.class),
                    ParameterizedTypeName.get(
                            ClassName.get(Class.class),
                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))
                    )
            );

            /*

              ```Map<String, RouteMeta>```
             */
            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(
                    ClassName.get(Map.class),
                    ClassName.get(String.class),
                    ClassName.get(RouteMeta.class)
            );

            /*
              Build input param name.
             */
            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, "routes").build();

            /*
              Build method : 'loadInto'
             */
            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)
                    .addAnnotation(Override.class)
                    .addModifiers(PUBLIC)
                    .addParameter(rootParamSpec);
```
在这里最终的生成的代码如下：
在这里生成的代码如下：
```java
    @Override
    public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {
	
    }
```

注： 这里loadInto()方法并不是ARouter$$Group$$activity类里的loadInto方法；

3. 对routeElements里Element元素逐一扫描其中注解Activity的元素，将该元素的相关环境变量及其本身封装入RouteMeta实例中；如果该Activity里的变量有使用@Autowired注解的话，那边把这些变量的注解元素封装入RouteMeta实例；最后 把RouteMeta实例以group为key的集合中：groupMap；

```java
            for (Element element : routeElements) {
                TypeMirror tm = element.asType();
                Route route = element.getAnnotation(Route.class);
                RouteMeta routeMeta;

                if (types.isSubtype(tm, type_Activity)) {                 // Activity
                    logger.info(">>> Found activity route: " + tm.toString() + " <<<");

                    // Get all fields annotation by @Autowired
                    Map<String, Integer> paramsType = new HashMap<>();
                    Map<String, Autowired> injectConfig = new HashMap<>();
                    for (Element field : element.getEnclosedElements()) {
                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !types.isSubtype(field.asType(), iProvider)) {
                            // It must be field, then it has annotation, but it not be provider.
                            //获取类变量中使用@Autowired进行注解的元素，
                            Autowired paramConfig = field.getAnnotation(Autowired.class);
                            //获取变量名
                            String injectName = StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name();
                            //typeUtils.typeExchange(field)将变量的类型转化ARouter的枚举类型TypeKind中一种，简单来说就是用int来代表变量类型；
                            paramsType.put(injectName, typeUtils.typeExchange(field));
                            injectConfig.put(injectName, paramConfig);
                        }
                    }
                    routeMeta = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);
                    routeMeta.setInjectConfig(injectConfig);
                }
				...

                categories(routeMeta);
            }
```
categories方法中就是RouteMeta放入groupMap；

另外在这里我们发现有一个新类RouteMeta, 该类是一个实体类，负责保存Route的基本数据；
```java
public class RouteMeta {
    /**
     * RouteType是Route的类型，该类型种类封装于RouteType枚举类中;
     * 包括：
     *     ACTIVITY(0, "android.app.Activity"),
     *     SERVICE(1, "android.app.Service"),
     *     PROVIDER(2, "com.alibaba.android.arouter.facade.template.IProvider"),
     *     CONTENT_PROVIDER(-1, "android.app.ContentProvider"),
     *     BOARDCAST(-1, ""),
     *     METHOD(-1, ""),
     *     FRAGMENT(-1, "android.app.Fragment"),
     *     UNKNOWN(-1, "Unknown route type");
     */
    private RouteType type;
	
    /**
     * Route的原始类型
     */
    private Element rawType;
	
    /**
     * 目的地（暂时不明白用处）
     */
    private Class<?> destination;
	
    /**
     * Route的路径：如@Route(path = "/activity/UrlActivity")中"/activity/UrlActivity"；
     */
    private String path;
	
    /**
     * Route的组名，如@Route(path = "/activity/UrlActivity")中的"activity";
     */
    private String group;
	
    /**
     * 优先级；注：值越小，优先级越高；
     */
    private int priority = -1;
	
    /**
     * extra数据
     */
    private int extra;

    /**
     * Route的名字，比如：@Route(name = "Tom",path = "/activity/UrlActivity") 中"Tom";
     */
    private String name;

    /**
     * 类的变量类型，key为变量名，value为TypeKind的类型；
     * TypeKind：该枚举类使用int来代表基本类型；
     */
    private Map<String, Integer> paramsType;

    /**
     * 所有将Autowired注解的变量的集合；以变量名为key；
     */
    private Map<String, Autowired> injectConfig;  // Cache inject config.
	...
}
```


这时候我们已经把所有使用Route注解的元素按Group分组放进了groupMap集合中；下面我们开始逐一取里面的group进行生成相应的代码；

4. 对group中所有目标页面进行解析，生成一个文件；最后输出类文件：ARouter$$Group$$activity；

```java
for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {
        String groupName = entry.getKey();

        /*
        生成group的loadInto方法，该空方法对于所有RouteType都适用：
        @Override
        public void loadInto(Map<String, RouteMeta> atlas) {
        }
        */
        MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)
                .addAnnotation(Override.class)
                .addModifiers(PUBLIC)
                .addParameter(groupParamSpec);

        List<RouteDoc> routeDocList = new ArrayList<>();

        // 生成group的方法体
        Set<RouteMeta> groupData = entry.getValue();
        for (RouteMeta routeMeta : groupData) {
            RouteDoc routeDoc = extractDocInfo(routeMeta);

            ClassName className = ClassName.get((TypeElement) routeMeta.getRawType());

                    ...

            // Make map body for paramsType
            /*
            生成"new java.util.HashMap<String, Integer>(){{put("obj", 11); put("mName", 8); put("girl", 0); put("age", 3); }}"
            中的 "put("obj", 11); put("mName", 8); put("girl", 0); put("age", 3);"
            */
            StringBuilder mapBodyBuilder = new StringBuilder();
            Map<String, Integer> paramsType = routeMeta.getParamsType();
            Map<String, Autowired> injectConfigs = routeMeta.getInjectConfig();
            if (MapUtils.isNotEmpty(paramsType)) {
                List<RouteDoc.Param> paramList = new ArrayList<>();

                for (Map.Entry<String, Integer> types : paramsType.entrySet()) {
                    mapBodyBuilder.append("put(\"").append(types.getKey()).append("\", ").append(types.getValue()).append("); ");
                }

                routeDoc.setParams(paramList);
            }
            String mapBody = mapBodyBuilder.toString();
            //生成loadInto方法的方法体代码；
            //atlas.put("/activity/ARouterUrlActivity", RouteMeta.build(RouteType.ACTIVITY, ARouterUrlActivity.class, "/activity/arouterurlactivity", "activity", new java.util.HashMap<String, Integer>(){{put("obj", 11); put("mName", 8); put("girl", 0); put("age", 3); }}, -1, -2147483648));
            loadIntoMethodOfGroupBuilder.addStatement(
                    "atlas.put($S, $T.build($T." + routeMeta.getType() + ", $T.class, $S, $S, " + (StringUtils.isEmpty(mapBody) ? null : ("new java.util.HashMap<String, Integer>(){{" + mapBodyBuilder.toString() + "}}")) + ", " + routeMeta.getPriority() + ", " + routeMeta.getExtra() + "))",
                    routeMeta.getPath(),
                    routeMetaCn,
                    routeTypeCn,
                    className,
                    routeMeta.getPath().toLowerCase(),
                    routeMeta.getGroup().toLowerCase());
        }

        // Generate groups
        //类名
        String groupFileName = NAME_OF_GROUP + groupName;
        JavaFile.builder(PACKAGE_OF_GENERATE_FILE, //包名:com.alibaba.android.arouter.routes
                TypeSpec.classBuilder(groupFileName)//类名
                        .addJavadoc(WARNING_TIPS) //注释
                        .addSuperinterface(ClassName.get(type_IRouteGroup)) //实现的接口
                        .addModifiers(PUBLIC) //类的权限
                        .addMethod(loadIntoMethodOfGroupBuilder.build()) //添加loadInto方法
                        .build()
        ).build().writeTo(mFiler); //输出类

        logger.info(">>> Generated group: " + groupName + "<<<");
        //将该group添加到根结点
        rootMap.put(groupName, groupFileName);
        //文档相关
        docSource.put(groupName, routeDocList);
    }
```

在这里，除了生成用@Route注解Activity的，还有@Route注解Server，Providers，Fragment，但生成代码原理是一样，在这里就不多说；

5. 现在类似把各个group里的ARouter$$Group$$activity已经全部生成了类文件了，接下来就生成把group注册到root的注册文件了： 
```java
	//更新loadInto的方法体，将每个group进行加入routes集合中；
    if (MapUtils.isNotEmpty(rootMap)) {
        // Generate root meta by group name, it must be generated before root, then I can find out the class of group.
        for (Map.Entry<String, String> entry : rootMap.entrySet()) {
            loadIntoMethodOfRootBuilder.addStatement("routes.put($S, $T.class)", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));
        }
    }

    // Write root meta into disk.
    String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;
            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,
            TypeSpec.classBuilder(rootFileName)
            .addJavadoc(WARNING_TIPS)
                            .addSuperinterface(ClassName.get(elementUtils.getTypeElement(ITROUTE_ROOT)))
            .addModifiers(PUBLIC)
                            .addMethod(loadIntoMethodOfRootBuilder.build())
            .build()
            ).build().writeTo(mFiler);

```

### @Autowired注解
@Autowired是用于注解变量的，可以帮忙我们自动从外部跳转过来Intent的extra中取数据赋值给使用@Autowired的变量；
我们还是以ARouterUrlActivity为例子：

```java
// 为每一个参数声明一个字段，并使用 @Autowired 标注
@Route(path = "/activity/UrlActivity")
public class ARouterUrlActivity extends Activity {
    @Autowired
    public String mName;
    @Autowired
    int age;
    @Autowired(name = "girl") // 通过name来映射URL中的不同参数
    boolean isBoy;

    /**
     * 如果需要传递自定义对象，新建一个类（并非自定义对象类）,
     * 然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)
     */
    @Autowired
    TestObj obj;    // 支持解析自定义对象，URL中使用json传递

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ARouter.getInstance().inject(this);
    }
```

在使用AutowiredProcessor处理器后会自动生成下面的代码：

```java
package com.yufen.arouterlib2.activity;

import android.util.Log;
import com.alibaba.android.arouter.facade.service.SerializationService;
import com.alibaba.android.arouter.facade.template.ISyringe;
import com.alibaba.android.arouter.launcher.ARouter;
import java.lang.Object;
import java.lang.Override;

/**
 * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */
public class ARouterUrlActivity$$ARouter$$Autowired implements ISyringe {
  private SerializationService serializationService;

  @Override
  public void inject(Object target) {
    serializationService = ARouter.getInstance().navigation(SerializationService.class);
    ARouterUrlActivity substitute = (ARouterUrlActivity)target;
    substitute.mName = substitute.getIntent().getStringExtra("mName");
    substitute.age = substitute.getIntent().getIntExtra("age", substitute.age);
    substitute.isBoy = substitute.getIntent().getBooleanExtra("girl", substitute.isBoy);
    if (null != serializationService) {
      substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra("obj"), new com.alibaba.android.arouter.facade.model.TypeWrapper<ARouterUrlActivity.TestObj>(){}.getType());
    } else {
      Log.e("ARouter::", "You want automatic inject the field 'obj' in class 'ARouterUrlActivity' , then you should implement 'SerializationService' to support object auto inject!");
    }
  }
}

```

那么@Autowired是怎么自动赋值的，其实很简单，我们看到ARouterUrlActivity的onCreate方法中需要调用ARouter.getInstance().inject(this)方法，而这个方法通过ARoute转调后，最终调用是上面utowiredProcessor处理器自动生成的ARouterUrlActivity$$ARouter$$Autowired.inject()方法；

至于AutowiredProcessor如何生成上面的代码， 这里不笔记了。

### @Intercepor注解

@Intercepor是用于注解拦截器的，对于@Intercepor并没有group的说法，因此拦截器相对很少，不需要像Route一样，需要group的机制来按需加载；也就是对于拦截器来说，是从app启动就进行初始化所有拦截器的；

```java
@Interceptor(priority = 6, name = "拦截器1号")
public class MyInterceptor1 implements IInterceptor {
    @Override
    public void process(Postcard postcard, InterceptorCallback callback) {
        Log.d("yufen","process: " + MyInterceptor1.class.getName());
        if((postcard.getExtra() & (InterceptConfigKey.INTERCEPT_VALUE_LOGIN)) > 0) {
            if (true) { //假设判断本地手机没安装支付宝，需要启动H5 Activity会登陆宝
               /* ARouter.getInstance().build("/activity/normalJumpActivity")
                        .navigation();*/
            }
            callback.onInterrupt(new RuntimeException("被拦截跳转到NormalJumpActivity了"));
        }
        callback.onContinue(postcard);
    }

    @Override
    public void init(Context context) {
        Log.d("yufen","init: " + MyInterceptor1.class.getName());
    }
}
```

InterceptorProcessor注解处理器会自动生成下面代码(还包含其它拦截器的)：

```java
package com.alibaba.android.arouter.routes;

/**
 * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */
public class ARouter$$Interceptors$$arouterlib2 implements IInterceptorGroup {
  @Override
  public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
    interceptors.put(5, MyInterceptor2.class);
    interceptors.put(6, MyInterceptor1.class);
  }
}
```

同样InterceptorProcessor如何生成上面的代码， 这里不笔记了。

整个Compile模块在代码编译阶段，可以预先生成路由关系等信息的类，生成的位置如下，然后这些类会被一同打包到最终 apk 中。


## API 模块学习

### ARouter初始化源码学习
在ARoute配置中，需要初始化SDK:
```java
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化
```

通过我们之前学习ARouter基本使用时，会发现所有调用基本都是通过ARouter这个类来调用的，其实ARouter只是一个代理类，实际上调用是_ARouter实例；而这两个ARouter,_ARouter类也就组成Launcher层；

下面我们看一下：ARouter的init方法：
```java
    /**
     * Init, it must be call before used router.
     */
    public static void init(Application application) {
        //保证只初始化一次
        if (!hasInit) {
            logger = _ARouter.logger;
            _ARouter.logger.info(Consts.TAG, "ARouter init start.");
			//真正初始化的调用_ARouter.init；
            hasInit = _ARouter.init(application);

            if (hasInit) {
                _ARouter.afterInit();//进行初始化后相关操作；
            }

            _ARouter.logger.info(Consts.TAG, "ARouter init over.");
        }
    }
```
从这里可以看到初始化时，真正调用是_ARouter.init()和afterInit()方法；
而_ARouter.init()调用 LogisticsCenter.init(mContext, executor)，我们接下来直接看该方法(只贴核心代码)：

```java
    /**
     * LogisticsCenter init, load all metas in memory. Demand initialization
     */
    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {
        try {
            long startInit = System.currentTimeMillis();
                Set<String> routerMap;
                // It will rebuild router map every times when debuggable.
				//如果在调试模块或版本号有更新，需要查找注解处理器生成的类；
                if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {
                    logger.info(TAG, "Run with debug mode or new install, rebuild router map.");
                    // These class was generated by arouter-compiler.
					//获取由ARouter-compiler生成的类；
                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);
                    if (!routerMap.isEmpty()) {
						//将所有类名保存入SharePreference，作为缓存，文件名为："SP_AROUTER_CACHE"
                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();
                    }
					//更新版本号
                    PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.
                } else {//直接缓存读取类；
                    logger.info(TAG, "Load router map from cache.");
                    routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));
                }

                logger.info(TAG, "Find router map finished, map size = " + routerMap.size() + ", cost " + (System.currentTimeMillis() - startInit) + " ms.");
                startInit = System.currentTimeMillis();
				//分别找到Group， 服务接口(Providers), 拦截器(Interceptors) 的注册类，调用它把相应的数据保存Warehouse中；
                for (String className : routerMap) {
                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {
                        // This one of root elements, load root.
                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);
                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {
                        // Load interceptorMeta
                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);
                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {
                        // Load providerIndex
                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);
                    }
                }
            }

            logger.info(TAG, "Load root element finished, cost " + (System.currentTimeMillis() - startInit) + " ms.");

            }
        } catch (Exception e) {
            throw new HandlerException(TAG + "ARouter init logistics center exception! [" + e.getMessage() + "]");
        }
    }
```
从上面来看，整个初始化流程分为两步： 
1. 查找ARouter-compiler注解处理器生成的所有类名；
2. 加载路由表;

##### 1. 查找ARouter-compiler注解处理器生成的所有类名
下面来看看步骤1怎么找到所有类名的， ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE)；ROUTE_ROOT_PAKCAGE是ARouter在compiler模块生成类的固定包："com.alibaba.android.arouter.routes"

a, 找到所有dex的路径：
```java
     //ClassUtils.java
    /**
     * get all the dex path
     *
     * @param context the application context
     * @return all the dex path
     * @throws PackageManager.NameNotFoundException
     * @throws IOException
     */
    public static List<String> getSourcePaths(Context context) throws PackageManager.NameNotFoundException, IOException {
        ApplicationInfo applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0);
        File sourceApk = new File(applicationInfo.sourceDir);

        List<String> sourcePaths = new ArrayList<>();
        //添加APK的路径(默认dex)
        sourcePaths.add(applicationInfo.sourceDir); //add the default apk path

        //the prefix of extracted file, ie: test.classes
        String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;

//        如果VM已经支持了MultiDex，就不要去Secondary Folder加载 Classesx.zip了，那里已经么有了
//        通过是否存在sp中的multidex.version是不准确的，因为从低版本升级上来的用户，是包含这个sp配置的
        if (!isVMMultidexCapable()) {//不支持Multi Dex, 这里有点不太明白，为什么说不支持时，会有多个dex的；
            //the total dex numbers
            int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);
            File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);

            for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {
                //for each dex file, ie: test.classes2.zip, test.classes3.zip...
                String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;
                File extractedFile = new File(dexDir, fileName);
                if (extractedFile.isFile()) {
					//把所有dex路径放入sourcePaths;
                    sourcePaths.add(extractedFile.getAbsolutePath());
                    //we ignore the verify zip part
                } else {
                    throw new IOException("Missing extracted secondary dex file '" + extractedFile.getPath() + "'");
                }
            }
        }
        //Instant相关
        if (ARouter.debuggable()) { // Search instant run support only debuggable
            sourcePaths.addAll(tryLoadInstantRunDexFile(applicationInfo));
        }
        return sourcePaths;
    }
```

b. 对所有dex文件进行扫描，找出里面的package name是"com.alibaba.android.arouter.routes"的类名：

```java
    /**
     * 通过指定包名，扫描包下面包含的所有的ClassName
     *
     * @param context     U know
     * @param packageName 包名
     * @return 所有class的集合
     */
    public static Set<String> getFileNameByPackageName(Context context, final String packageName) throws PackageManager.NameNotFoundException, IOException, InterruptedException {
        final Set<String> classNames = new HashSet<>();
        //找到所有dex的路径；
        List<String> paths = getSourcePaths(context);
        final CountDownLatch parserCtl = new CountDownLatch(paths.size());

        for (final String path : paths) {
            //把任务放入线程池中；
            DefaultPoolExecutor.getInstance().execute(new Runnable() {
                @Override
                public void run() {
                    DexFile dexfile = null;

                    try {
                        if (path.endsWith(EXTRACTED_SUFFIX)) {//针对zip作特殊处理；不了解这块，所以不明白为什么会有zip出现；
                            //NOT use new DexFile(path), because it will throw "permission error in /data/dalvik-cache"
                            dexfile = DexFile.loadDex(path, path + ".tmp", 0);
                        } else {
                            dexfile = new DexFile(path);
                        }

                        Enumeration<String> dexEntries = dexfile.entries();
                        while (dexEntries.hasMoreElements()) {//循环查找
                            String className = dexEntries.nextElement();
                            if (className.startsWith(packageName)) {
                                classNames.add(className);//找到指定包名的类；
                            }
                        }
                    } catch (Throwable ignore) {
                        Log.e("ARouter", "Scan map file in dex files made error.", ignore);
                    } finally {
                        if (null != dexfile) {
                            try {
                                dexfile.close();
                            } catch (Throwable ignore) {
                            }
                        }

                        parserCtl.countDown();
                    }
                }
            });
        }

        parserCtl.await();

        Log.d(Consts.TAG, "Filter " + classNames.size() + " classes by packageName <" + packageName + ">");
        return classNames;
    }
```

找到所有类名后，将其保存SharePreference中 SP_AROUTER_CACHE.xml文件，可自行查看；

##### 2. 加载路由表

分别在步骤1中找到的所有类名中， 找到Root， 服务接口(Providers), 拦截器(Interceptors) 的注册类，调用它把相应的数据保存Warehouse中；

在这里我们需要先认识一下 Warehouse 类： Warehouse位于Core层，Ware House主要存储了ARouter在运行期间加载的一些配置文件以及映射关系；

```java
class Warehouse {
    // Cache route and metas
    static Map<String, Class<? extends IRouteGroup>> groupsIndex = new HashMap<>();
    static Map<String, RouteMeta> routes = new HashMap<>();

    // Cache provider
    static Map<Class, IProvider> providers = new HashMap<>();
    static Map<String, RouteMeta> providersIndex = new HashMap<>();

    // Cache interceptor
    static Map<Integer, Class<? extends IInterceptor>> interceptorsIndex = new UniqueKeyTreeMap<>("More than one interceptors use same priority [%s]");
    static List<IInterceptor> interceptors = new ArrayList<>();
}
```

1. 把ARouter$$Root$$+包名(如ARouter$$Root$$arouterlib2)， 把所有分组注册到groupsIndex集合，方便后面按组加载；

	该集合包括Activity、服务等，使用来讲，就是所有使用@Route注解的，都添加到该集合中了；
```java
/**
 * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */
public class ARouter$$Root$$arouterlib2 implements IRouteRoot {
  @Override
  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {
    routes.put("activity", ARouter$$Group$$activity.class);
    routes.put("degrade", ARouter$$Group$$degrade.class);
    routes.put("service", ARouter$$Group$$service.class);
    routes.put("xxx", ARouter$$Group$$xxx.class);
  }
}
```
2. 把服务管理的 ARouter$$Providers$$+包名，把接口及其实现类封装放入providersIndex集合中；
   该集合主要记录某服务接口分别有哪些真正的服务实现类的信息；
```java
public class ARouter$$Providers$$arouterlib2 implements IProviderGroup {
  @Override
  public void loadInto(Map<String, RouteMeta> providers) {
    providers.put("com.yufen.baselib.arouter.server_interface.ISayService", RouteMeta.build(RouteType.PROVIDER, DogSayServiceImpl.class, "/service/dog", "service", null, -1, -2147483648));
    providers.put("com.yufen.baselib.arouter.server_interface.ISayService", RouteMeta.build(RouteType.PROVIDER, HumanSayServiceImpl.class, "/service/human", "service", null, -1, -2147483648));
    providers.put("com.alibaba.android.arouter.facade.service.SerializationService", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, "/service/json", "service", null, -1, -2147483648));
    providers.put("com.alibaba.android.arouter.facade.service.PretreatmentService", RouteMeta.build(RouteType.PROVIDER, PretreatmentServiceImpl.class, "/xxx/xxx", "xxx", null, -1, -2147483648));
    providers.put("com.alibaba.android.arouter.facade.service.DegradeService", RouteMeta.build(RouteType.PROVIDER, DegradeServiceImplTest.class, "/degrade/hhhhh", "degrade", null, -1, -2147483648));
  }
}
```

3. 把拦截器的 ARouter$$Interceptors$$+包名，把接口及其实现类封装放入 interceptorsIndex 集合中
```java
public class ARouter$$Interceptors$$arouterlib2 implements IInterceptorGroup {
  @Override
  public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
    interceptors.put(5, MyInterceptor2.class);
    interceptors.put(6, MyInterceptor1.class);
  }
}
```

到这里， 整个初始化就完成了， 很简单，就是把所有Route表，服务接口对应真正实现类，拦截器的数据进行注册到WareHouse中；

### Frossard 层
Frossard层是可以被外部调用的，Frossard层其实包含了三部分，分别是：Service、Callback和Template，这里的Service概念和服务端的Service概念是相似的，也是在客户端的简单引申，但是却不同于Android组件中的Service，这里的Service是ARouter抽象出来的概念，从本质上讲，这里的Service是接口，从意义上讲是将一定的功能和组件封装成接口，并对外提供能力。Template则是模板，主要用于在编译期执行的SDK，这个SDK会在编译期生成一些映射文件，而这些映射文件会按照Template组件中提供的模板来生成，这样按照一定的规则和约束生成映射文件也方便Route在运行的时候进行读取。

Frossard 层的提供接口的，我们在基本使用中和Compile模块学习中，都基本上接触过这些接口了，这里不多讲；这里讲一个重要的实体类： PostCard; 

##### PostCard类
该实体类中包含某个路由的信息， 该类继承于RouteMeta类；下面介绍该类的变量：
```java
public final class Postcard extends RouteMeta {
    // 基本属性
    /**
     * Uri,比如由外部导航进行的Url,比如："arouter://yufen.zhi.com/test/activity2"
     */
    private Uri uri;
    private Object tag;             // A tag prepare for some thing wrong.
    private Bundle mBundle;         // Data to transform
    /**
     * 可指定Flag; 如跳转Activity时的Flag
     */
    private int flags = -1;         // Flags of route
    private int timeout = 300;      // Navigation timeout, TimeUnit.Second
    /**
     * 如果是服务接口的话，该变量会保存真正实现接口的服务类对象；
     */
    private IProvider provider;     // It will be set value, if this postcard was provider.
    /**
     * 是否开通绿色通道(开通的话，意味着直接跳转拦截器的尝试拦截)
     */
    private boolean greenChannel;
    /**
     * 该变量为实现SerializationService接口的类，可进行对象数据转json，json转对象的实现；
     */
    private SerializationService serializationService;

    // 动画相关
    private Bundle optionsCompat;    // The transition animation of activity
    /**
     * 进入/退出动画对应的anim资源文件；如： withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)
     */
    private int enterAnim = -1;
    private int exitAnim = -1;
}
```

同时这里也附上RouteMeta的变量说明，方便查阅：
```java
public class RouteMeta {
    /**
     * RouteType是Route的类型，该类型种类封装于RouteType枚举类中;
     * 包括：
     *     ACTIVITY(0, "android.app.Activity"),
     *     SERVICE(1, "android.app.Service"),
     *     PROVIDER(2, "com.alibaba.android.arouter.facade.template.IProvider"),
     *     CONTENT_PROVIDER(-1, "android.app.ContentProvider"),
     *     BOARDCAST(-1, ""),
     *     METHOD(-1, ""),
     *     FRAGMENT(-1, "android.app.Fragment"),
     *     UNKNOWN(-1, "Unknown route type");
     */
    private RouteType type;
	
    /**
     * Route的原始类型
     */
    private Element rawType;
	
    /**
     * 该变量针对服务接口的，该变量保存某路径下真实实现类的类；
     */
    private Class<?> destination;
	
    /**
     * Route的路径：如@Route(path = "/activity/UrlActivity")中"/activity/UrlActivity"；
     */
    private String path;
	
    /**
     * Route的组名，如@Route(path = "/activity/UrlActivity")中的"activity";
     */
    private String group;
	
    /**
     * 优先级；注：值越小，优先级越高；
     */
    private int priority = -1;
	
    /**
     * extra数据
     */
    private int extra;

    /**
     * Route的名字，比如：@Route(name = "Tom",path = "/activity/UrlActivity") 中"Tom";
     */
    private String name;

    /**
     * 类的变量类型，key为变量名，value为TypeKind的类型；
     * TypeKind：该枚举类使用int来代表基本类型；
     */
    private Map<String, Integer> paramsType;

    /**
     * 所有将Autowired注解的变量的集合；以变量名为key；
     */
    private Map<String, Autowired> injectConfig;  // Cache inject config.
	...
}
```


### LogisticsCenter 层

在开始看跳转Activity和服务管理的源码之前，我们需要先学习一下LogisticsCenter，如下ARouter的结构图一样，整个SDK的流转以及内部调用最终都会下沉到LogisticsCenter层；

##### 1. 初始化方法：
```java
public synchronized static void init(Context context, ThreadPoolExecutor tpe)
```
该方法已经在上面ARouter初始化时学习，略过；

##### 根据服务名字创建PostCard 对象: Postcard buildProvider(String serviceName)

服务名字一般为该服务的类名，如 XXXService.class, 那么服务名字就是 "XXXService"; 

```java
    /**
     * Build postcard by serviceName
     *
     * @param serviceName interfaceName
     * @return postcard
     */
    public static Postcard buildProvider(String serviceName) {
		//直接从Warehouse.providersIndex集合中Service name 对应的RouteMeta；
        RouteMeta meta = Warehouse.providersIndex.get(serviceName);

        if (null == meta) {
            return null;
        } else {
			//如果RouteMeta存在，那么创建一个新的PostCard;
            return new Postcard(meta.getPath(), meta.getGroup());
        }
    }
```

注意，这里PostCard对象只是有了path和group的信息而已， 这时候的信息还不足以让我们通过它来调用对应的服务， 还需要使用LogisticsCenter.completion()进行填充相应的信息；

##### 2. 对PostCard对象根据其path和group信息进行填充其它信息；completion(Postcard postcard)
该方法源码相当长，我们分开一步一步看：

1. 先根据Path来从Warehouse.routes集合中拿到相对应的RouteMeta对象；
```java
	RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());
```
2. 如果Warehouse.routes集合中没有该路径下的RouteMeta对象， 说明该路径下的Group还没加载，那就需要加载一下；

	a, 根据Group来从Warehouse.groupsIndex拿对应IRouteGroup的类，通过IRouteGroup class的构建方法来构建IRouteGroup实例；
	
	b, 调用IRouteGroup.loadInto(Warehouse.routes)把PostCard对应的Group下的所有路径都注册到Warehouse.routes中；
	
	c, 最后把加载的group从Warehouse.groupsIndex中删除；
	
	d, 最后重新调用completion方法；
	
```java
        Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.
            if (null == groupMeta) {
                throw new NoRouteFoundException(TAG + "There is no route match the path [" + postcard.getPath() + "], in group [" + postcard.getGroup() + "]");
            } else {
                // Load route and cache it into memory, then delete from metas.
                try {
                    if (ARouter.debuggable()) {
                        logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] starts loading, trigger by [%s]", postcard.getGroup(), postcard.getPath()));
                    }
                    //根据Group来从Warehouse.groupsIndex拿对应IRouteGroup的类，通过IRouteGroup class的构建方法来构建IRouteGroup实例；
                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();
                    //调用IRouteGroup.loadInto(Warehouse.routes)把PostCard对应的Group下的所有路径都注册到Warehouse.routes中；
                    iGroupInstance.loadInto(Warehouse.routes);
                    //最后把加载的group从Warehouse.groupsIndex中删除；
                    Warehouse.groupsIndex.remove(postcard.getGroup());

                    if (ARouter.debuggable()) {
                        logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] has already been loaded, trigger by [%s]", postcard.getGroup(), postcard.getPath()));
                    }
                } catch (Exception e) {
                    throw new HandlerException(TAG + "Fatal exception when loading group meta. [" + e.getMessage() + "]");
                }
                //最后重新调用completion方法；
                completion(postcard);   // Reload
            }
```

3. 如果Warehouse.routes集合中有该路径下的RouteMeta对象， 那么使用RouteMeta对象设置PostCard的相应属性；

	a, 根据RouteMeta对象设置PostCard的 Destination、Type、Priority、Extra属性；
	
	b, 取出PastCard中的Uri对象，提取uri中参数部分生成Map集合，然后从RouteMeta对象取出ParamsType集合对象；（上面我们说过ParamsType对象里面包含我们使用@Autowired注解进行自动转化的变量的类型，key为变量名，value为TypeKind的类型）， 再把uri提取的数据一个个和ParamsType对比及转化相应对象保存到Postcard的mBundle变量中；再把整个uri转字符串的保存到mBundle中ARouter.RAW_URI作为key对应的value中；
	
	c, 针对RouteMeta对象的type属性是PROVIDER的，需要找到它的真实实现类(因为同样的接口，会有不一样的真实实现类)：
	
		1) 通过Destination属性获取其实现类的Class;
		
		2) 根据实现类的Class从Warehouse.providers集合中拿对应实现类的实例；如果不存在，则创建实现类的实例，并放入Warehouse.providers集合中； 
		
		3) 把实现类的实例设置到PostCard的provider属性中；
		
		4) 为该PostCard开户绿色通道；
		
	d, 针对RouteMeta对象的type属性是FRAGMENT的，为该PostCard开户绿色通道；
	
```java
            //a
			postcard.setDestination(routeMeta.getDestination());
            postcard.setType(routeMeta.getType());
            postcard.setPriority(routeMeta.getPriority());
            postcard.setExtra(routeMeta.getExtra());
            //b
            Uri rawUri = postcard.getUri();
            if (null != rawUri) {   // Try to set params into bundle.
                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);
                Map<String, Integer> paramsType = routeMeta.getParamsType();

                if (MapUtils.isNotEmpty(paramsType)) {
                    // Set value by its type, just for params which annotation by @Param
                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {
                        setValue(postcard,
                                params.getValue(),
                                params.getKey(),
                                resultMap.get(params.getKey()));
                    }

                    // Save params name which need auto inject.
                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));
                }

                // Save raw uri
                postcard.withString(ARouter.RAW_URI, rawUri.toString());
            }
            //c
            switch (routeMeta.getType()) {
                case PROVIDER:  // if the route is provider, should find its instance
                    // Its provider, so it must implement IProvider
                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();
                    IProvider instance = Warehouse.providers.get(providerMeta);
                    if (null == instance) { // There's no instance of this provider
                        IProvider provider;
                        try {
                            provider = providerMeta.getConstructor().newInstance();
                            provider.init(mContext);
                            Warehouse.providers.put(providerMeta, provider);
                            instance = provider;
                        } catch (Exception e) {
                            throw new HandlerException("Init provider failed! " + e.getMessage());
                        }
                    }
                    postcard.setProvider(instance);
                    postcard.greenChannel();    // Provider should skip all of interceptors
                    break;
                case FRAGMENT:
                    postcard.greenChannel();    // Fragment needn't interceptors
                default:
                    break;
            }
```
	
### Launcher 层

Launcher层主要是ARouter实例的实现和各种对外提供链式调用的API；我们这里通过ARouter的基本使用一步步查看源码来学习一下；

#### Activity的跳转和获取某服务接口的实现类实例

基本Activity跳转使用源码：
```java
    ARouter.getInstance() // 获取ARouter对象
        .build("/activity/normalJumpActivity") // 输入目标Activity的路径
        .withString("key1","HelloWord!") //传输参数
        .navigation(this, REQUEST_CODE, new NavigationCallback() {
            @Override
            public void onFound(Postcard postcard) {
                    Log.d(TAG,"找到了");
                    }
            
            @Override
            public void onLost(Postcard postcard) {
                    Log.d(TAG,"找不到");
                    }
            
            @Override
            public void onArrival(Postcard postcard) {
                    Log.d(TAG,"跳转完了");
                    }
            
            @Override
            public void onInterrupt(Postcard postcard) {
                    Log.d(TAG,"被拦截了");
                    }
        }); //进行跳转
```

获取某服务类的实例：
```java
ISayService humanSayService3 = (ISayService)ARouter.getInstance().build("/service/human").navigation();
```

注： ARouter只是一个代理类，实际上调用是_ARouter实例的方法

1, build()方法最终返回一个PostCard实例，该实例暂时包含输入的参数： path及Group(Group: "activity", path: "/activity/normalJumpActivity") 或及uri；

使用该方法目的是让ARouter知道我们想要跳转到哪个Activity；

```java
    /**
     * Build postcard by uri
     */
    protected Postcard build(Uri uri) {
        if (null == uri || TextUtils.isEmpty(uri.toString())) {
            throw new HandlerException(Consts.TAG + "Parameter invalid!");
        } else {
            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);
            if (null != pService) {
                uri = pService.forUri(uri);
            }
            return new Postcard(uri.getPath(), extractGroup(uri.getPath()), uri, null);
        }
    }

    /**
     * Build postcard by path and group
     */
    protected Postcard build(String path, String group) {
        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {
            throw new HandlerException(Consts.TAG + "Parameter is invalid!");
        } else {
            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);
            if (null != pService) {
                path = pService.forString(path);
            }
            return new Postcard(path, group);
        }
    }
```

2, withXXX()方法是把跳转的参数放入PostCard中mBundl属性中， 可传基本类型，数组和实现序列化的对象；

```java
    /**
     * Set object value, the value will be convert to string by 'Fastjson'
     *
     * @param key   a String, or null
     * @param value a Object, or null
     * @return current
     */
    public Postcard withObject(@Nullable String key, @Nullable Object value) {
        serializationService = ARouter.getInstance().navigation(SerializationService.class);
        mBundle.putString(key, serializationService.object2Json(value));
        return this;
    }

    // Follow api copy from #{Bundle}

    /**
     * Inserts a String value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key   a String, or null
     * @param value a String, or null
     * @return current
     */
    public Postcard withString(@Nullable String key, @Nullable String value) {
        mBundle.putString(key, value);
        return this;
    }
	....
```
另外还可以通过withTransition(int enterAnim, int exitAnim) 设置其Activity的进/退动画；
	

3, 通过步骤1，2后， 目标Activity及传送的数据已经确定了；然后通过navigation进行真实的跳转；其中方法的REQUEST_CODE, new NavigationCallback()参数是可选的；
设置REQUEST_CODE的话， 相当startActivityForResult()，退出目标Activity后，会回调onActivityResult()来返回结果；
NavigationCallback回调是对于监听ARouter跳转过来是否找到目标Activity或已经跳转到了目标Acitivity了事件 及 找到目标Activity后是否被拦截的事件；

所有navigation方法最终调用是_ARouter的protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback)；
我们把方法进行分段说明：

a, 根据路径来查找目标并根据其目标类来完善PostCard类的属性(LogisticsCenter.completion(postcard)); 

```java
		//是否有实现PretreatmentService接口进行重定向路径；
        PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class);
        if (null != pretreatmentService && !pretreatmentService.onPretreatment(context, postcard)) {
            // Pretreatment failed, navigation canceled.
            return null;
        }

        try {
            //目前目标路径来完善PostCard里的信息；
            LogisticsCenter.completion(postcard);
        } catch (NoRouteFoundException ex) {
            logger.warning(Consts.TAG, ex.getMessage());
            //调试模式下输出异常的log;
            if (debuggable()) {
                // Show friendly tips for user.
                runInMainThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(mContext, "There's no route matched!\n" +
                                " Path = [" + postcard.getPath() + "]\n" +
                                " Group = [" + postcard.getGroup() + "]", Toast.LENGTH_LONG).show();
                    }
                });
            }

            if (null != callback) {
                //回调NavigationCallback监听的找不到目标的回调；
                callback.onLost(postcard);
            } else {
                // No callback for this invoke, then we use the global degrade service.
                //如果用户没设置监听，那边检测是否有实现全局降级处理的DegradeService接口， 有则进行降级通知处理；
                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);
                if (null != degradeService) {
                    degradeService.onLost(context, postcard);
                }
            }

            return null;
        }

        if (null != callback) {
            //回调NavigationCallback监听的已找到目标的回调；
            callback.onFound(postcard);
        }
```

b, 如果该跳转没有开启绿色通道的话(只针对没开启绿色通道的Activty， 服务接口或获取Fragment默认开启绿色通道)， 那么进行拦截处理(重点：该拦截处理是异步的)：
在这里先不理是怎么拦截的(后面再单独讲)，只需要知道通过拦截器处理后，能通过则继续调用_navigation(context, postcard, requestCode, callback)方法，被拦截掉的话，会回调NavigationCallback；

```java
        if (!postcard.isGreenChannel()) {   // It must be run in async thread, maybe interceptor cost too mush time made ANR.
            interceptorService.doInterceptions(postcard, new InterceptorCallback() {
                /**
                 * Continue process
                 *
                 * @param postcard route meta
                 */
                @Override
                public void onContinue(Postcard postcard) {
                    _navigation(context, postcard, requestCode, callback);
                }

                /**
                 * Interrupt process, pipeline will be destory when this method called.
                 *
                 * @param exception Reson of interrupt.
                 */
                @Override
                public void onInterrupt(Throwable exception) {
                    if (null != callback) {
						//回调NavigationCallback监听的目标已被拦截的回调；
                        callback.onInterrupt(postcard);
                    }

                    logger.info(Consts.TAG, "Navigation failed, termination by interceptor : " + exception.getMessage());
                }
            });
        } else {
            return _navigation(context, postcard, requestCode, callback);
        }
```

c, 我们来看_navigation(context, postcard, requestCode, callback)核心方法；主要是根据目标路径不同类型来进行处理；
如果是Activity，则根据属性进行跳转目标Activity；如果是服务或Fragment之类的，则返回找到的相应的实例；

```java
    private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {
        final Context currentContext = null == context ? mContext : context;

        switch (postcard.getType()) {
            case ACTIVITY: //目标路径是Activity；
                // Build intent
                final Intent intent = new Intent(currentContext, postcard.getDestination());
                intent.putExtras(postcard.getExtras());

                // Set flags.
                int flags = postcard.getFlags();
                if (-1 != flags) {
                    intent.setFlags(flags);
                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.
                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                }

                // Set Actions
                String action = postcard.getAction();
                if (!TextUtils.isEmpty(action)) {
                    intent.setAction(action);
                }

                // Navigation in main looper.
                runInMainThread(new Runnable() {
                    @Override
                    public void run() {
                        startActivity(requestCode, currentContext, intent, postcard, callback);
                    }
                });

                break;
            case PROVIDER:
                return postcard.getProvider();//返回对应服务实现类；
            case BOARDCAST:
            case CONTENT_PROVIDER:
            case FRAGMENT:
                Class fragmentMeta = postcard.getDestination();
                try {
                    Object instance = fragmentMeta.getConstructor().newInstance();
                    if (instance instanceof Fragment) {
                        ((Fragment) instance).setArguments(postcard.getExtras());
                    } else if (instance instanceof android.support.v4.app.Fragment) {
                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());
                    }

                    return instance;
                } catch (Exception ex) {
                    logger.error(Consts.TAG, "Fetch fragment instance error, " + TextUtils.formatStackTrace(ex.getStackTrace()));
                }
            case METHOD:
            case SERVICE:
            default:
                return null;
        }

        return null;
    }
	
	//根据不同的属性来启动Activity；
    private void startActivity(int requestCode, Context currentContext, Intent intent, Postcard postcard, NavigationCallback callback) {
        //requestCode不为0，说明需要使用 返回结果；
        if (requestCode >= 0) {  // Need start for result
            if (currentContext instanceof Activity) {
                ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());
            } else {
                logger.warning(Consts.TAG, "Must use [navigation(activity, ...)] to support [startActivityForResult]");
            }
        } else {
            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());
        }
        //设置进场及退场动画
        if ((-1 != postcard.getEnterAnim() && -1 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.
            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());
        }
        ////回调NavigationCallback监听的目标已完成的回调；
        if (null != callback) { // Navigation over.
            callback.onArrival(postcard);
        }
    }

```
到这里，整个ARouter路由器根据路径来跳转Activity或获取某服务实例时，可以说是很简单的， 核心点是LogisticsCenter.completion(postcard)语句；该方法在LogisticsCenter 层已详细介绍源码了；

#### 拦截器实现源码

##### 实例InterceptorServiceImpl对象及拦截器初始化
在ARouter初始化时，会根据"/arouter/service/interceptor"来获取InterceptorServiceImpl实例并将其缓存到_ARouter实例中；
```java
	private static InterceptorService interceptorService;
    static void afterInit() {
        // Trigger interceptor init, use byName.
        interceptorService = (InterceptorService) ARouter.getInstance().build("/arouter/service/interceptor").navigation();
    }
```
在获取InterceptorServiceImpl实例过程中， 在LogisticsCenter.completion()时， 会调用该IProvider接口init();
也就调用InterceptorServiceImpl.init()方法，该方法会进行加载所有拦截器并调用其init()方法进行初始化；

```java
	if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) {
        for (Map.Entry<Integer, Class<? extends IInterceptor>> entry : Warehouse.interceptorsIndex.entrySet()) {
			Class<? extends IInterceptor> interceptorClass = entry.getValue();
			try {
				//实例每个拦截器对象；
				IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();
				iInterceptor.init(context);
				//添加到缓存
				Warehouse.interceptors.add(iInterceptor);
			} catch (Exception ex) {
				throw new HandlerException(TAG + "ARouter init interceptor error! name = [" + interceptorClass.getName() + "], reason = [" + ex.getMessage() + "]");
			}
        }

        interceptorHasInit = true;

        logger.info(TAG, "ARouter interceptors init over.");

		synchronized (interceptorInitLock) {
			interceptorInitLock.notifyAll();
        }
	}
```

##### 拦截流程

我们前面说到当跳转时，如果是Activity类型会进行调用拦截器进行拦截：interceptorService.doInterceptions(postcard, new InterceptorCallback() {}; 
我们来看看该方法是怎么逐一调用各个拦截器拦截的：

```java
    @Override
    public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) {
        //是否有实现拦截器
        if (null != Warehouse.interceptors && Warehouse.interceptors.size() > 0) {
            //检查拦截器是否初始化完了，如果没则等待10秒；10秒后还没初始化完则抛出HandlerException异常；
            checkInterceptorsInitStatus();

            if (!interceptorHasInit) {
                callback.onInterrupt(new HandlerException("Interceptors initialization takes too much time."));
                return;
            }

            LogisticsCenter.executor.execute(new Runnable() {
                @Override
                public void run() {
                    CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size());
                    try {
						//开始拦截
                        _excute(0, interceptorCounter, postcard);
                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);
                        if (interceptorCounter.getCount() > 0) {    // Cancel the navigation this time, if it hasn't return anythings.
                            callback.onInterrupt(new HandlerException("The interceptor processing timed out."));
                        } else if (null != postcard.getTag()) {    // Maybe some exception in the tag.
                            callback.onInterrupt(new HandlerException(postcard.getTag().toString()));
                        } else {
                            callback.onContinue(postcard);
                        }
                    } catch (Exception e) {
                        callback.onInterrupt(e);
                    }
                }
            });
        } else {
            callback.onContinue(postcard);
        }
    }

    /**
     * Excute interceptor
     *
     * @param index    current interceptor index
     * @param counter  interceptor counter
     * @param postcard routeMeta
     */
    private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) {
        if (index < Warehouse.interceptors.size()) {
            IInterceptor iInterceptor = Warehouse.interceptors.get(index);
            //进行该拦截器的拦截处理：
            iInterceptor.process(postcard, new InterceptorCallback() {
                @Override
                public void onContinue(Postcard postcard) {
                    // Last interceptor excute over with no exception.
                    counter.countDown();
                    //当前拦截器没拦截，则进行下一个拦截器的处理；
                    _excute(index + 1, counter, postcard);  // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.
                }

                @Override
                public void onInterrupt(Throwable exception) {
                    // Last interceptor excute over with fatal exception.

                    postcard.setTag(null == exception ? new HandlerException("No message.") : exception.getMessage());    // save the exception message for backup.
                    counter.cancel();
                }
            });
        }
    }

```

到这里，整个ARouter的源码笔记就结束了；

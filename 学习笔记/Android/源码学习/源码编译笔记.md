## 源码编译笔记

### 编译系统

##### Makefile

`Android`平台的编译系统，其实就是用`Makefile`写出来的一个独立项目。它定义了编译的规则，实现了“自动化编译”，不仅把分散在数百个`Git`库中的代码整合起来、统一编译， 而且还把产物分门别类地输出到一个目录，打包成手机`ROM`，还可以生成应用开发时所使用的`SDK`、`NDK`等。
因此，采用`Makefile`编写的编译系统，也可以称为`Makefile`编译系统。

#####  Android.mk

`Makefile`编译系统的一部分，`Android.mk`是`android`编译环境下的一种特殊的“makefile”文件, 它是经过了`android`编译系统处理的。`Android.mk`中定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译你的源代码，并生成对应的目标文件。

##### Ninja

`Ninja`是一个致力于速度的小型编译系统，如果把其他的编译系统看作高级语言，那么`Ninja`目标就是汇编。使用Ninja 主要目的就是因为其编译速度快。

##### Soong

`Soong`是谷歌用来替代此前的`Makefile`编译系统的替代品，负责解析`Android.bp`文件，并将之转换为Ninja文件；

##### Blueprint

`Blueprint`用来解析`Android.bp`文件翻译成`Ninja`语法文件;

##### kati

`kati`是谷歌专门为了`Android`而开发的一个小项目，基于`Golang`和`C++`。 目的是把`Android`中的`Makefile`，转换成`Ninja`文件。

##### Android.bp

`Android.bp`是用来替换`Android.mk`的配置文件。

`Android.mk、Ninja、Soong、Blueprint、kati、Android.bp`的概念之间的联系为：
![VZRxYQ.png](https://s2.ax1x.com/2019/05/27/VZRxYQ.png)

`Blueprint`负责解析`Android.bp`文件内容，`Blueprint`类似一个处理相关语法的库文件，`Soong`则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是`Soong`借助于`Blueprint`定义的`Android.bp`语法，完成`Android.bp`的解析，最终转换成`Ninja`文件。

`Makefile`文件会通过`kati`转换为`Ninja`文件。

随着`Android`工程越来越大，采用`Makefile`的编译系统花费的时间也越来越长，因此谷歌在`Android 7.0`开始引入了`Ninja`来编译系统，相对于`Makefile`来说`Ninja`在大的项目管理中速度和并行方面有突出的优势。

`Makefile`默认文件名为`Makefile`或`makefile`，也常用`.make`或`.mk`作为文件后缀。 `Ninja`的默认文件名是`build.ninja`，其它文件以`.ninja`为后缀。

`Makefile`与`Ninja`的区别在于, `Makefile`是设计来给开发编写的，而`Ninja`设计出来是给其它程序生成的。如果`Makefile`是`Java`语言，那么`Ninja`就是汇编语言。

### 编译源码

`Androd`系统源码编译有很多种方式，主要有以下几种：

- 在`Linux`中直接进行系统源码编译（Android官方支持）
- 在`Mac OS`中直接进行系统源码编译（Android官方支持）
- 使用[Docker](https://www.docker.com/products)编译，支持Mac OS和Windows

#### Linux编译环境

- 设置处理器数量

- 安装 jdk8

  ```shell
  sudo apt-get update
  sudo apt-get install openjdk-8-jdk
  ```

- 使用 ubuntu 14+，需要安装以下依赖包：

  ```shell
  sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip
  ```

#### 源码整编

- 在`AOSP`的根目录，执行下面：

  ```shell
  source build/envsetup.sh
  make clobber
  ```

  使用 build目录中的`envsetup.sh`脚本初始化环境，这个脚本会引入其他的执行脚本。`make clobber`用于清除缓存。

- 选择编译目标
  执行命令：

  ```shell
  lunch
  ```

  `lunch`命令是`envsetup.sh`里定义的一个命令，用来让用户选择编译目标。

  会有以下信息输出：

  ```shell
  You're building on Linux
  
  Lunch menu... pick a combo:
       1. aosp_arm-eng
       2. aosp_arm64-eng
       3. aosp_mips-eng
       4. aosp_mips64-eng
       5. aosp_x86-eng
       6. aosp_x86_64-eng
       7. aosp_car_arm-userdebug
       8. aosp_car_arm64-userdebug
       9. aosp_car_x86-userdebug
       10. aosp_car_x86_64-userdebug
       11. mini_emulator_arm64-userdebug
       12. m_e_arm-userdebug
       13. m_e_mips64-eng
       14. m_e_mips-userdebug
       15. mini_emulator_x86_64-userdebug
       16. mini_emulator_x86-userdebug
       17. uml-userdebug
       18. aosp_cf_x86_auto-userdebug
       19. aosp_cf_x86_phone-userdebug
       20. aosp_cf_x86_tablet-userdebug
       21. aosp_cf_x86_tablet_3g-userdebug
       22. aosp_cf_x86_tv-userdebug
       23. aosp_cf_x86_wear-userdebug
       24. aosp_cf_x86_64_auto-userdebug
       25. aosp_cf_x86_64_phone-userdebug
       26. aosp_cf_x86_64_tablet-userdebug
       27. aosp_cf_x86_64_tablet_3g-userdebug
       28. aosp_cf_x86_64_tv-userdebug
       29. aosp_cf_x86_64_wear-userdebug
       30. cf_x86_auto-userdebug
       31. cf_x86_phone-userdebug
       32. cf_x86_tablet-userdebug
       33. cf_x86_tablet_3g-userdebug
       34. cf_x86_tv-userdebug
       35. cf_x86_wear-userdebug
       36. cf_x86_64_auto-userdebug
       37. cf_x86_64_phone-userdebug
       38. cf_x86_64_tablet-userdebug
       39. cf_x86_64_tablet_3g-userdebug
       40. cf_x86_64_tv-userdebug
       41. cf_x86_64_wear-userdebug
       42. aosp_marlin-userdebug
       43. aosp_marlin_svelte-userdebug
       44. aosp_sailfish-userdebug
       45. aosp_walleye-userdebug
       46. aosp_walleye_test-userdebug
       47. aosp_taimen-userdebug
       48. hikey-userdebug
       49. hikey64_only-userdebug
       50. hikey960-userdebug
  
  Which would you like? [aosp_arm-eng]
  ```

  意思就是要你选择编译目标的格式，编译目标的格式组成为`BUILD-BUILDTYPE`，比如`aosp_arm-eng`的`BUILD`为`aosp_arm`，`BUILDTYPE`为`eng`。

  其中`BUILD`表示编译出的镜像可以运行在什么环境，`aosp`代表Android开源项目，`arm`表示系统是运行在`arm`架构的处理器上。
  更多参考[官方文档](https://source.android.google.cn/source/running.html#selecting-device-build)。
  `BUILDTYPE` 指的是编译类型，有以下三种：

  - user：用来正式发布到市场的版本，权限受限，如没有 root 权限，不能 dedug，adb默认处于停用状态。
  - userdebug：在user版本的基础上开放了 root 权限和 debug 权限，adb默认处于启用状态。一般用于调试真机。
  - eng：开发工程师的版本，拥有最大的权限(root等)，具有额外调试工具的开发配置。一般用于模拟器。

  如果你没有`Nexus /ˈneksəs/ `设备，只想编译完后运行在模拟器查看，那么`BUILD`可以选择`aosp_x86`，`BUILDTYPE`选择eng，`Which would you like? [aosp_arm-eng]`后面直接输入对应序号5就可以。

  也可以直接指定编译的目标：

  ```shell
  lunch aosp_x86-eng
  ```

  或者（不同的系统版本，序号的对应会有差别，建议不要直接用序号）

  ```shell
  lunch 5
  ```

- 开始编译
  通过`-jN`参数来设置编译的并行任务数，以提高编译速度，在此前我的CPU核心数为6，这里N值最好选在6到12之间，这里我们设置6个并行任务进行编译:

  ```
  make -j6
  ```

  整编成功后会打印类似如下内容：
  ![img](https://s2.ax1x.com/2019/05/27/VZWpSs.png)

  最终会在`out/target/product/generic_x86/`目录生成了三个重要的镜像文件： `system.img、userdata.img、ramdisk.img`。

  > - system.img：系统镜像，里面包含了Android系统主要的目录和文件，通过init.c进行解析并mount挂载到/system目录下。
  > - userdata.img：用户镜像，是Android系统中存放用户数据的，通过init.c进行解析并mount挂载到/data目录下。
  > - ramdisk.img：根文件系统镜像，包含一些启动Android系统的重要文件，比如init.rc。

#### 运行模拟器

在编译完成之后,就可以通过以下命令运行`Android`虚拟机了，命令如下:

```
source build/envsetup.shlunch aosp_x86-engemulator
```

如果是在编译完后运行虚拟机，由于之前已经执行过`source`和`lunch`命令了，可以直接运行：

```
emulator
```

如果不出意外就会启动模拟器，如果出现报错，网上也有很多的解决方案。

### 源码单编

在AOSP根目录执行：

```
source build/envsetup.sh
lunch aosp_x86-eng
```

进入Settings的目录：

```
cd packages/apps/Settings
```

mm编译当前目录下的模块，不编译依赖模块。

```
mm
```

编译成功后会有提示生成文件的存放路径。
![img](https://s2.ax1x.com/2019/05/27/VZW9ln.png)

除了`Settings.odex`文件，还会在`out/target/product/generic_x86/system/priv-app/Settings`目录下生成`Settings.apk`。

此外还有以下命令可以进行单编：

- mmm：编译指定目录下的模块，不编译它所依赖的其它模块。
- mma：编译当前目录下的模块及其依赖项。
- mmma：编译指定路径下所有模块，并且包含依赖。

如果你修改了源码，想查看生成的APK文件，有两种方式：

1. 通过`adb push`或者`adb install `来安装APK。
2. 使用`make snod`命令，重新生成 system.img，运行模拟器查看。

本文来自于： http://liuwangshu.cn/batcoder/aosp/3-compiling-aosp.html
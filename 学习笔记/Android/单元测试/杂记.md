

## 概述

### Android测试主要分为三个方面：

```
单元测试（Junit4、Mockito、PowerMockito、Robolectric）
UI测试（Espresso、UI Automator）
压力测试（Monkey）
```



### Why 

- **测试驱动： 先写其单元测试，再其方法的实现代码；**

  为什么程序员讨厌写单元测试？为什么他们甚至更讨厌在写代码之前先写单元测试？
  正常来说，当你需要解决一个软件问题时， 你要做的第一件事是什么？ 你在想怎么解决它(需要写什么代码来来生成一个解决方案)，当然这是你必须做的，但是后面要做的事； 
  对于测试驱动来说，第一个问题应该是“我怎么知道我已经解决这个问题？” 

- **代码可读性提早，方法边界清楚;**
  单元测试是示例代码的一部分。 我们都遇到过一些我们不知道怎么用的方法和类库。第一个我们要找的地方就是示例代码。示例代码就是文档。

- **造就更好的设计(重用)，减少/提早发现/易定位Bug;**
  测试一小部分代码迫使你定义这些代码要负责什么。如果你可以容易地做到这点，就意味着代码的职责是定义良好的。因此，它具有高内聚的特性。如果你可以对你的代码进行单元测试，那么就意味着你可以像绑定到测试一样容易地将它与系统的其他部分进行绑定。所以，它与它周围的其他部分是低耦合的。高内聚低耦合是优秀的、可维护的设计的定义。那些容易进行单元测试的代码也是易于维护的。

## 基础 Junit

JUint是Java编程语言的单元测试框架，用于编写和运行可重复的自动化测试。

现在Junit 有Junit4/5的版本： 

- JUnit 5旨在调整java 8样式的编码，并且比JUnit 4更强大和灵活。
- Junit 4需要Java 5或更高版本 / Junit 5需要Java 8或更高版本;

### 特点：

- 提供注解来识别测试方法。
- 提供断言来测试预期结果。
- JUnit 测试允许你编写代码更快，并能提高质量。
- JUnit 优雅简洁。没那么复杂，花费时间较少。
- JUnit测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。
- JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。
- JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。

### 注解

```
@BeforeClass/@AfterClass 必须为静态方法
```

生命周期 

**@Ignore**：可暂不执行该方法， 不建议用，往往后面很容易忽略它，导致没修复。

**@Runwith**

- 首先要分清几个概念：测试方法、测试类、测试集、测试运行器。
- 其中测试方法就是用@Test注解的一些函数。
- 测试类是包含一个或多个测试方法的一个Test.java文件。
- 测试集是一个suite，可能包含多个测试类。
- 测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。
- 而@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。常见的运行器有：
  - @RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用junit的参数化功能
  - @RunWith(Suite.class) @SuiteClasses({ATest.class,BTest.class,CTest.class})测试集运行器配合使用测试集功能
  - @RunWith(JUnit4.class) junit4的默认运行器
  - @RunWith(JUnit38ClassRunner.class) 用于兼容junit3.8的运行器
  - 一些其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能

**@Parameters**： 用于使用参数化功能。

@RunWith 和 @Suite 这两个注解是用来运行套件测试

### 断言

assertSame  断言两个对象引用同一个对象，相当于“==”  

assertNotSame  断言两个对象引用不同的对象，相当于“!=”

assertThat  断言实际值是否满足指定的条件

直接打开Assert源码进行解释吧；

## Mockito

Mockito 是一个用于 Java 单测的 Mock 框架，除了 JUnit 之外，它还可以用于其他单测框架（例如：TestNG）。`Mockito` 通过mock可以模拟各种各样的对象，来代替真正的对象做出希望的响应，能够让我们更加专注地去测试代码逻辑，省去了构造数据所花费的努力。

Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。

### mock 测试概念

示例说明： 

从图中可以清晰的看出, mock对象就是在调试期间用来作为真实对象的替代品。

Mock 最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。

### 场景

- 真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)
- 真实对象很难被创建(比如具体的web容器)
- 真实对象的某些行为很难触发(比如网络错误)
- 真实情况令程序的运行速度很慢
- 真实对象有用户界面
- 测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)
- 真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)

### 基本使用

##### Class mock/Partial mock: 

Class Mock 改变了 class 的行为，所以 mock 出来的对象就完全失去了原来的行为， 比如你通过Mock对象调用一个方法，并不会直接运行该方法，只是Mock对象会记录下这次行为(stubbing);
如果没有对 method 进行插桩(Stub)，那么 method 会返回默认值（`null`、`false`、`0`等）；

##### stub

仅仅 Mock 出来一个对象显然是不够的，虽然可以通过验证**方法的执行情况**来测试代码的逻辑，但是多数情况下我们还需要改变方法的返回值，这时就需要用到“插桩”。

一个方法可多次Stub，或一次stub多次返回结果；

doReturn

设定某void方法返回结果, 或者有些情况下无法使用when来设置返回结果时；



### 进阶使用

ArgumentMatcher： 

注：一旦某个方法的参数使用了参数匹配，则该方法所有的参数都得使用参数匹配；



##### doCallRealMethod

设定某void方法调用时可运行其内部真正的逻辑；

一般来说，要真实运行方法里的语句，最好使用 spy 方式进行，但有时候针对第三方接口等时，用它会更简单；



#### 注解

**@Mock注解** 

使用@Mock注解来定义mock对象有如下的优点： 

1. 方便mock对象的创建 
2. 减少mock对象创建的重复代码 
3. 提高测试代码可读性 
4. 变量名字作为mock对象的标示，所以易于排错 

**@Spy注解** 

**@Captor注解** ： 参数捕获器的注解

**@InjectMocks注解** ： 通过这个注解，可实现自动注入mock对象。

#### 覆盖率： 

类/方法/行覆盖率； 

JaCoCo 工具：

JaCoCo是一个开源的覆盖率工具(官网地址： http://www.eclemma.org/JaCoCo/ )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。

## Robolectric

Junit 属于 JVM 平台上的单元测试框架，无法提供 Android 运行时环境。如果在单元测试中涉及到 Android 特性，Junit 则无法实现。

因此在Android上，是启动 Android 模拟器(或真机)进行测试(Android Test)。但是在模拟器上运行测试用例是非常低效的，构建、安装、启动，每个步骤都异常耗时，为了解决这一问题，Robolectric 通过 mock Android 运行时环境，使得单元测试可以在 JVM 环境上运行。

而Robolectric测试在一个沙箱中运行，每个测试都为其配置Android环境，将每个测试之间进行隔离，并使用测试API扩展Androd框架，这些API可以对Android框架的行为和断言状态的可见性提供微小的控制。

注： 有些Android组件的常规行为，这Robolectric也不太好测试，比如硬件传感器之类的；

Robolectric主要适用于UI的测试，比如Activity，Fragment，一些页面操作的测试场景，采用Shadow的方式对Android中的组件进行模拟测试，从而实现Android单元测试Robolectric正好弥补了Mockito的不足，两者结合使用是最完美的。

### Shadow

Shadow是Robolectric的核心。Robolectric里，定义了大量对应android源码的shadow类。shadow类，如其名“影子”。当一个android类的方法被调用的时候，Robolectric就会尝试寻找该类相应的影子类，替代对应的android类，执行相应的方法。

DLInterceptHandler



### PowerMockito

PowerMock使用一个自定义类加载器和字节码操作来模拟静态方法，构造函数，final类和方法，私有方法，去除静态初始化器等等。



### Mockk



### Approvals

对于实体类来说，都是定义一些属性及相应的set/get方法； 所以相应单元测试写起来也很简单，但每个set/get方法都会覆盖到，常规方法写起来就烦人；


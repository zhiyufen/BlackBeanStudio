## 桥接模式笔记

[TOC]

亦称： Bridge

**桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

![](https://refactoringguru.cn/images/patterns/content/bridge/bridge.png)

桥接模式通过将继承改为组合的方式来解决问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。

### 桥接模式结构图

![](res\bridge_structure.PNG)

### 伪代码

**桥接**模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。  `设备`Device类作为实现部分， 而 `遥控器`Remote类则作为抽象部分。

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/example-zh.png)



#### 抽象部分

```kotlin
/**
 * “抽象部分”定义了两个类层次结构中“控制”部分的接口。
 * 它管理着一个指向“实现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。
 */
open class RemoteControl(private val device: IDevice) {
    /**
     * 按下电源键
     */
    fun togglePower() {
        if (device.isEnabled()) {
            device.enable()
        } else {
            device.disable()
        }
    }

    fun volumeDown() {
        device.setVolume(device.getVolume() - 10)
    }

    fun volumeUp() {
        device.setVolume(device.getVolume() + 10)
    }

    fun channelDown() {
        device.setChannel(device.getChannel() - 1)
    }

    fun channelUp() {
        device.setChannel(device.getChannel() + 1)
    }
}

// 精确抽象 (可选)
/**
 * 你可以独立于设备类的方式从抽象层中扩展类。
 */
class AdvancedRemoteControl(private val device: IDevice): RemoteControl(device) {
    fun mute() {
        device.setVolume(0)
    }
}
```

#### 实现部分

```kotlin
/**
 * “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相匹配。
 * 实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，
 * 而抽象接口则会基于这些操作定义较高层次的操作。
 */
interface IDevice {
    fun isEnabled(): Boolean
    fun enable()
    fun disable()
    fun getVolume(): Int
    fun setVolume(percent: Int)
    fun getChannel(): Int
    fun setChannel(channel: Int)
}
```

#### 具体实现

```kotlin
/**
 * 所有设备都遵循相同的接口。
 */
 
 // 电视
class TVDevice: IDevice {
    private var isTurnOn: Boolean = false
    private var volumeNum: Int = 0
    private var channelNum: Int = 0

    override fun isEnabled(): Boolean {
        return isTurnOn
    }

    override fun enable() {
        isTurnOn = true
    }
    ...
}
// 收音机
class RadioDevice: IDevice {
    ...
}
```

#### 客户端

```kotlin
// 客户端代码中的某个位置
fun main(){
    val tvRemote = RemoteControl(TVDevice())
    tvRemote.togglePower()
    tvRemote.channelUp()
    tvRemote.volumeDown()
    
    val radioRemote = AdvancedRemoteControl(RadioDevice())
    radioRemote.togglePower()
    radioRemote.channelUp()
    radioRemote.mute()
}
```

### 应用场景

-  **如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。**
  类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。

  桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。

- **如果你希望在几个独立维度上扩展一个类， 可使用该模式。**
  桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。

- **如果你需要在运行时切换不同实现方法， 可使用桥接模式。**
  桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。

  这一点是很多人混淆桥接模式和[策略](https://refactoringguru.cn/design-patterns/strategy)模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。

### 实现方式

1. 明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。
2. 了解客户端的业务需求， 并在抽象基类中定义它们。
3. 确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。
4. 为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。
5. 在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。
6. 如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。
7. 客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。

### 优缺点

- **优点：**
  - 你可以创建与平台无关的类和程序。
  - 客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。
  - *开闭原则*。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。
  - *单一职责原则*。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。
- **缺点：**
  - 对高内聚的类使用该模式可能会让代码更加复杂。

### 与其它模式的关系

- **桥接模式**通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， **适配器模式**通常在已有程序中使用， 让相互不兼容的类能很好地合作。
- **桥接**、 **状态模式**和**策略模式** （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于**组合模式**——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
- 你可以将**抽象工厂模式**和**桥接**搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
- 你可以结合使用**生成器模式**和**桥接模式**： 主管类负责抽象工作， 各种不同的生成器负责实现工作。



> 本文笔记于 https://refactoringguru.cn/design-patterns/bridge
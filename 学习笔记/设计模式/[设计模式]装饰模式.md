## 装饰模式

[TOC]

**亦称：** 装饰者模式、装饰器模式、Wrapper、Decorator

**装饰模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

![](https://refactoringguru.cn/images/patterns/content/decorator/decorator.png)

注：聚合 （或组合） 组合是许多设计模式背后的关键原则 （包括装饰在内）

*封装器*是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。  “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。

### 装饰模式结构

![](res\wrapper_stucture.PNG)

### 伪代码

在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。

![](https://refactoringguru.cn/images/patterns/diagrams/decorator/example.png)

程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：

- 当数据即将被**写入磁盘**前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。
- 当数据刚**从磁盘读出**后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。

#### 部件

声明封装器和被封装对象的公用接口。

```kotlin
/**
 * 装饰可以改变组件接口所定义的操作。
 */
interface IDataSource {
    fun writeDate(data: String)
    fun readData(): String
}
```

#### 具体部件

类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。

```kotlin
/**
 * 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。
 */
class FileDataSource(val fileName: String): IDataSource {
    // 这里不把数据放在文件中，暂时放在内存中
    private var data: String = ""
    override fun writeDate(data: String) {
        this.data = data
    }

    override fun readData(): String {
        return data
    }
}
```

#### 基础装饰

类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。

```kotlin
/**
 * 装饰基类和其他组件遵循相同的接口。
 * 该类的主要任务是定义所有具体装饰的封装接口。
 * 封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并且负责对其进行初始化。
 */
open class DataSourceDecorator(private var wrapper: IDataSource): IDataSource {
    override fun writeDate(data: String) {
        wrapper.writeDate(data)
    }

    override fun readData(): String {
        return wrapper.readData()
    }
}
```

#### 具体装饰类

定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。

```kotlin

/**
 * 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。
 * 饰必须在调用封装对象之前或之后执行额外的行为。
 */
class EncryptionDecorator(wrapper: IDataSource): DataSourceDecorator(wrapper) {
    /**
     * 1. 压缩传递数据。
     * 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。
     */
    override fun writeDate(data: String) {
        val data1 = data + "AB"
        super.writeDate(data)
    }

    /**
     * 1. 通过被封装对象的 readData（读取数据）方法获取数据。
     * 2. 如果数据被加密就尝试解密。
     * 3. 返回结果。
     */
    override fun readData(): String {
        val data =  super.readData()
        return data.substring(0, data.length -2)
    }
}

/**
 * 你可以将对象封装在多层装饰中。
 */
class CompressionDecorator(wrapper: IDataSource): DataSourceDecorator(wrapper) {
    /**
     * 1. 加密传递数据。
     * 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法。
     */
    @RequiresApi(Build.VERSION_CODES.O)
    override fun writeDate(data: String) {
        super.writeDate(Base64.getEncoder().encodeToString(data.toByteArray()))
    }

    /**
     * 1. 通过被封装对象的 readData（读取数据）方法获取数据。
     * 2. 如果数据被加密就尝试解密。
     * 3. 返回结果。
     */
    @RequiresApi(Build.VERSION_CODES.O)
    override fun readData(): String {
        val data =  super.readData()
        return Base64.getDecoder().decode(data).toString()
    }
}
```

#### 客户端

可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。

```kotlin
/**
 * 选项 1：装饰组件的简单示例
 */
class Application {
    @RequiresApi(Build.VERSION_CODES.O)
    fun dumbUsageExample() {
        val str = "HelloWord!"
        //将明码数据写入目标文件
        val source = FileDataSource("tempFile.txt")
        source.writeDate(str)

        // 将压缩数据写入目标文件。
        val compress = CompressionDecorator(source)
        compress.writeDate(str)

        // 将压缩且加密的数据写入目标文件。
        // Encryption > Compression > FileDataSource
        val encrypt = EncryptionDecorator(compress)
        encrypt.writeDate(str)
    }
}

/**
 * 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心数据如何存储。
 * 它们会与提前配置好的数据源进行交互，数据源则是通过程序配置器获取的。
 */
class SalaryManager(val source: IDataSource) {
    fun load(): String {
        return source.readData()
    }

    fun save(data: String) {
        source.writeDate(data)
    }
}

/**
 * 程序可在运行时根据配置或环境组装不同的装饰堆桟。
 */
class ApplicationConfigurator {
    private val enabledEncryption = true
    private val enabledCompression = true
    fun configurationExample() {
        var source: IDataSource = FileDataSource("tempFile.txt")
        if (enabledEncryption) {
            source = CompressionDecorator(source)
        }
        if (enabledCompression) {
            source = EncryptionDecorator(source)
        }

        val logger = SalaryManager(source)
        val salary = logger.load()
    }
}
```

### 应用场景

- 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。
  装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。
- 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。
  许多编程语言使用 `final`最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。

### 实现方式

1. 确保业务逻辑可用一个基本组件及多个额外可选层次表示。
2. 找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。
3. 创建一个具体组件类， 并定义其基础行为。
4. 创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。
5. 确保所有类实现组件接口。
6. 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。
7. 客户端代码负责创建装饰并将其组合成客户端所需的形式。

### 优缺点

- 优点：
  - 你无需创建新子类即可扩展对象的行为。
  - 你可以在运行时添加或删除对象的功能。
  - 你可以用多个装饰封装对象来组合几种行为。
  - *单一职责原则*。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。
- 缺点：
  - 在封装器栈中删除特定封装器比较困难。
  - 实现行为不受装饰栈顺序影响的装饰比较困难。
  - 各层的初始化配置代码看上去可能会很糟糕。

### 与其它模式的关系

- **适配器模式**可以对已有对象的接口进行修改， **装饰模式**则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

- **适配器**能为被封装对象提供不同的接口， **代理模式**能为对象提供相同的接口， **装饰**则能为对象提供加强的接口。

- **责任链模式**和**装饰模式**的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

  **责任链**的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种**装饰**可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。

- **组合模式**和**装饰**的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。

  **装饰**类似于**组合**， 但其只有一个子组件。 此外还有一个明显不同： *装饰*为被封装对象添加了额外的职责， *组合*仅对其子节点的结果进行了 “求和”。

  但是， 模式也可以相互合作： 你可以使用**装饰**来扩展**组合**树中特定对象的行为。

- 大量使用**组合**和**装饰**的设计通常可从对于**原型模式**的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

- **装饰**可让你更改对象的外表， **策略模式**则让你能够改变其本质。

- **装饰**和**代理**有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。



> 本文笔记于https://refactoringguru.cn/design-patterns/decorator，更详细请前往；
## 正则表达式

本文笔记来源于《精通正则表达式（第三版本）》

最近打算写一个小功能，而这个小功能需要使用正则表达式来解析短信中我所需要的信息， 虽然之前也从网上看过正则表达式使用的文章，但都不是系统的，基本都是要用什么就查什么，然后就拿来用，而无法知道是否它的性能怎样，是否有更好的易用，性能又好的表达式，都不得而知。因此系统学一下，以后免得又是到时无头苍蝇一样去搜索；

### Egrep 元字符

Egrep 与grep一样是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来， 是Linux系统中常用的工具；

##### 行的起始和结束

在检查一行文本时， 使用脱字符 “^” 代表一行的开始；以美元符"$"代表一行的结束；

```xml
^cat$
```

##### 字符组

[...] 字符组，它容许使用者列出在某处期望匹配的字符；

比如： gr[ea]y  能匹配到 gray, grey; [ea] 表示能匹配e或者a即可；



在字符组里,有一个字符组元字符：  “-” 连字符表示一个范围： 比如 [0-9], [a-z]; 多重范围也是容许的，例如：[0123456789abcdefgABCDEFG] 可以表示成：[0-9a-gA-G]; 

注：只有在字符组内部，连字符才是元字符， 否则它就是只能匹配普通的连字符号；



##### 排除型字符组

用 "[^]" 取代 [...], 这个字符组就会匹配任何未列出的字符；

```
[^0-1] //匹配除了0到6以外的任何字符；
```

注： 排除型字符组表示“匹配一个未列出的字符”，而不是“不要匹配列出的字符”；这个表示就很好解释了下面不匹配的例子：

```java
q[^u]

Iraqi  //匹配
Iraqax //匹配
qoph   //匹配
Qoph   //不匹配
Iraq   //不匹配， q[^u]要求q之后紧跟一个u以外的字符(通常来说，结尾会有一个换行字符，但egrep在匹配正则表达式之前把这些换行符去掉，其它软件也是一样)
```

 

##### 用点号匹配任意字符

元字符“.” 是用来匹配任意字符的字符组的简便写法；

```java
03.19.76

03.19.76  //匹配
03/19/76  //匹配
03-19/76  //匹配
```

注: 点号在字符组里并不是元字符，只是单纯一个点号而，或者说元字符在字符组都不是元符号，只是本身表示的符号

#### 多选结构

##### 匹配任意子表达式

“|” 元符号，表示是“或”， 使用它，可以把不同的子表达式组合与一个总的表达式，而该总的表达式又能够匹配任意的子表达式；子表达式称为“多选分支”；

```java
Bob|Robert
grey|gray 或者 gr(e|a)y  // 等同于 gr[ea]y
//其中上面括号划定多选结构的范围的
```

##### 忽略大小写

egrep的命令行参数"-i"

```
egrep -i path build.gradle
```

##### 单词分界符

可使用“元字符序列”：  "\\<"  "\\>" 来匹配单词的开头和结束位置(有时egrep版本不支持)；

```java
\<cat/>

cat  //匹配
acat //不匹配
```

在Java中可以使用 “\\b” ；

小结：

| 元字符 | 名称         | 匹配对象                       |
| ------ | ------------ | ------------------------------ |
| .      | 点号         | 单个任意字符                   |
| [...]  | 字符组       | 列出的任意字符                 |
| [^...] | 排除型字符组 | 未列出的任意字符               |
| ^      | 脱字符       | 行的起始位置                   |
| $      | 美元符       | 行的结束位置                   |
| \\<    | 反斜线-小于  | 单词的起始位置                 |
| \\>    | 反斜线-大于  | 单词的结束位置                 |
| \|     | 竖线         | 匹配分隔两边的任意一个表达式   |
| (...)  | 括号         | 限制竖线的作用范围，及其它功能 |

-----

#### 可选项元素

元符号“？” 表示可选项，把它加在一个字符的后面，表示此处容许出现这个字符，但不是匹配成功的必要条件；

```java
colou?r //可以匹配 colour, color
4(th)?  //可以匹配  4, 4th;  ()里表示一个整体，而？跟在后面表示作用对象是“th”
```

##### 其它量词：重复出现

元字符 “+” 表示之前紧邻的元素出现一次或者多次；

元字符 “*” 表示之前紧邻的元素出现任意多次，或者不出现；

问号，加号，星号这3个元字符，统称量词，它们限定了所作用元素的匹配次数；

比如要匹配： <HR SIZE = 14> 这样的文件

```
<HR * SIZE *= *[0-9]+ *
```

注： 空格符也是普通字符之一；

小结：

|            | 次数下限 | 次数上次 | 含义                                         |
| ---------- | -------- | -------- | -------------------------------------------- |
| ？         | 无       | 1        | 可以不出现，也可以只出现一次(单次可选)       |
| *          | 无       | 无       | 可以出现无数次，也可以不出现（任意次数均可） |
| +          | 1        | 无       | 可以出现无数次，但至少要出现一次（至少一次） |
| {min, max} |          |          | 至少需要min次，至多容许max次                 |

------

##### 

##### 规定重现次数的范围：区间

**区间量词**定义重现次数的区间：“....{min, max}” ，表示容许的重现次数在 min 到 max 之间；

##### 括号及反向引用

在正则表达式中，括号能够“记住”它们包含的子表达式匹配的文本。 而反向引用 “\1”， “\2”， “\3” 等来表示第一，第二，第三组括号匹配的文本。

```java
([a-z])([0-9])\1\2  //\1代表匹配[a-z]内容， \2代表匹配[0-9]内容
```



#####  转义

使用 “\” + 元符号 可以转元符号转成普通的字符；

```
\.
\([a-z]\) // (a)
```

##### 更多例子：

```
[a-zA-Z_0-9][a-zA-Z_0-9]  //变量名
“[^"]*”  //引号内的字符串
\$[0-9]+(\.[0-9][0-9]?) //美元金额（可能包含小数）
\<http[s]?://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!~*%$]*\.html?\> //网站 url
(1[012]|[1-9]):[0-5][0-9] (am|pm) //12小时制的时刻
[01]?[0-9]|2[0-3]:[0-5][0-9]      //24小时制的时刻
```



Other:

```
\t  //制表符
\n  //换行符
\r  //回车符
\s  //匹配所有“空白”， 包括空格符，制表符，换行符和回车符。
\S  //除"\s"之外的任何字符
\w  //[a-zA-Z0-9]
\W  //除"\w"之外的任何字符
\d  //[0-9]， 即数字
\D  //除"\d"之外的任何字符
```

-----



#### Java中的正则处理

使用 Sun 提供的 java.util.regex包

```java
import java.util.regex.*

Pattern r = Pattern.compile("^Sujbecet: {.*}", RegexOptions.IgnoreCase);
Matcher m = r.matcher(line);
if (m.find()) {
    subject = m.group(1); //第一个括号内的子表达式匹配的文本；
}

//Or
if (!Pattern.matchers("\\s", line)) {
    //如果line不是空行
}

//有些Java对象自身整合了正则表达式的，比如String
if (!line.matchers("\\s")) {
    //...
}

```

注： 字符串中每个'\\' 都必须转义为 '\\\\', 比如 ‘\\w’ 必须写成 '\\\\w'; 

查找和替换，可使用 matcher类的 m.replaceAll("aaa") ; 

----

##### 表达式的匹配原理

Java属于 传统型的NFA(另外一个是DFA)；

两条普适的原则：

- 优先选择最左端 （最靠开头）的匹配结果；
- 标准的匹配量词（*、+、？ 和 {m,n}） 是匹配优先的。 

###### 规则1：优先选择最左端 （最靠开头）的匹配结果

概念：匹配先从需要查找的字符串的起始位置尝试匹配。如果在当前位置测试了所有的可能之后 不能找到匹配结果，就需要从字符串的第二个字符之前的位置开始重新尝试。在找到匹配结果前必须在所有的位置重复此过程。只有在尝试过所有的起始位置（直到字符串的最后一个字符）都不能找到匹配结果的情况下，才会报告匹配失败；

比如使用 fat|cat|belly|your 来匹配字符串 “The dragging belly indicates that your cat is too fat”;

第一个匹配结果是 belly 而不是 fat; 

##### 规则2：标准的匹配量词（*、+、？ 和 {m,n}） 是匹配优先的

用这些量词来约束某个表达式，在匹配成功之前，进行尝试的次数是存在上限和下限的。 而规则2表明，这些尝试总是希望获得最长的匹配；

简单来说，标准匹配量词的结果“可能” 并非所有可能中最长的，但它们总是尝试匹配尽可能多的字符，直到匹配上限为止。 

比如我们使用 “\b\w+s\b” 来匹配包含 ‘s’ 的字符串，如：“regexes” ; 

'\w+' 会尽可能匹配多的字符，那么刚开始会匹配整个“regexes”, 再去匹配 's' 就无法匹配；

但由于's'是必须匹配的字符， 那么就要要求逐一把字符串一个个吐出来，先释放出来一个 's';  那么后面正则表达式 's\b' 就匹配成功了；如果不行，还要释放更多的字符；所以‘\w+’ 只匹配到了“regexe”；

JAVA 是NFA型的， 它的原理是回溯机制；

在回溯过来中，有一个重要原则：

- 如果需要在“进行尝试” 和 “跳过尝试” 之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”， 而对于忽略优先量词（??, *?, +?），会选择“跳过尝试” 。 
- 距离当前最近储存的选项就是当本地失败强制回溯时使用的原则是LIFO(后进先出)。

占有优先量词： ?+, *+, ++, {m,n}+ 与匹配优先量词很相似，只是它们从来不交还已经匹配的字符.

量词种类意义: 

贪婪	勉强	侵占
X?		X??		X?+		  匹配 X 零次或一次
X*		X*?		X*+		     匹配 X 零次或多次
X+		X+?		X++		匹配 X 一次或多次
X{n}	X{n}?	X{n}+	   匹配 X n 次
X{n,}	X{n,}?	X{n,}+	匹配 X 至少 n 次
X{n,m}	X{n,m}?	X{n,m}+	匹配 X 至少 n 次，但不多于 m 次

在贪婪、勉强和侵占三个量词间有着细微的不同。


贪婪量词之所以称之为"贪婪的"，是由于它们强迫匹配器读入(或者称之为吃掉)整个输入的字符串，来优先尝试第一次匹配，如果第一次尝试匹配（对整个输入的字符串）失败，匹配器会通过回退整个字符串的一个字符再一次进行尝试，不断的进行处理直到找到一个匹配，或者左边没有更多的字符用来回退了。赖于在表达式中使用的量词，最终它将尝试地靠着1或0个字符的匹配。

但是，勉强量词采用相反的路径：从输入字符串的开始处开始，因此每次勉强地吞噬一个字符来寻找匹配，最终它们尝试整个输入的字符串。



更详细原理和例子，还请看书了，原理嘛， 理解了就好， 这里就不作详细笔记了。

# 正则表达式基本语法 

#### 1、元字符

| **元字符 **                | **说明 **                                          |
| -------------------------- | -------------------------------------------------- |
| **.**                      | 匹配除了换行符之外的其他**任意一个字符**           |
| **[abc] **                 | 字符集合，匹配**集合中任意一个字符**               |
| **[^abc]**                 | 字符集合，匹配**除了集合中任意一个字符**           |
| **[a-z]、[0-9]、[A-Z]**    | 字符范围，匹配字符**范围内的任意一个字符**         |
| **[^a-z]、[^0-9]、[^A-Z]** | 字符范围，匹配**除了字符范围内的任意一个字符**     |
| **\d**                     | 匹配**一位数字**，等价于[0-9]                      |
| **\D **                    | 匹配**一个非数字**，等价于[^0-9]                   |
| **\s**                     | 匹配**1位空白字符**，包括换行符，制表符，空格      |
| **\S **                    | 匹配**1位非空白字符**                              |
| **\w**                     | 匹配**一个合法的标识符**，字母、数字、下划线和中文 |
| **\W **                    | 匹配**1个特殊字符**                                |

#### 2、位置控制字符

| **正则表达式** | **说明**         | **举例**                                          |
| -------------- | ---------------- | ------------------------------------------------- |
| **\b**         | 匹配单词的边界   | \bb：表示匹配b开头的单词 b\b：表示匹配b结尾的单词 |
| **\B**         | 不匹配单词的边界 | t\B：表示不匹配以t结尾的单词，比如write           |
| **^**          | 表示行首位置     | –                                                 |
| **$**          | 表示行尾位置     | –                                                 |

#### 3、次数控制字符

| **正则表达式** | **说明 **                             | **举例**                             |
| -------------- | ------------------------------------- | ------------------------------------ |
| *** **         | 表示前面的1个字符可以重复任意次数     | 单词doogear用"o\w*"可以匹配oogear    |
| **+ **         | 表示前面的1个字符最少出现一次         | 单词doogear用"o\w+"可以匹配oogear    |
| **? **         | 表示前面的1个字符最多出现一次         | 单词doogear用"o\w?"可以匹配oo        |
| **{n} **       | 表示前面的1个字符必须出现n次          | 单词doogear用"o\w{3}"可以匹配ooge    |
| **{n,}**       | 表示前面的1个字符必须出现n次以上      | 单词doogear用"o\w{3,}"可以匹配oogear |
| **{n,m}**      | 表示前面的1个字符必须出现n次到m次之间 | 单词doogear用"o\w{3,5}"可以匹配oogea |

#### 4、分组

| **正 则 表 达 式**                 | **说明**                                                     | **举例**                                                     |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **pattern1\|pattern2**             | 匹配pattern1或者pattern2，如果pattern1或者pattern2都能匹配内容，则**整个表达式的匹配结果是他们分别匹配的结果的合并**。 | 单词doogear用"ary\|doo"可以匹配doo。 单词doogear用"a\|do\w{1}"可以匹配doo和a。 |
| **(pattern) **                     | 使用小括号表示分组匹配，可以改变优先级，而且匹配的内容可以通过反向引用捕获，**通过‘\数字’进行获取**相应分组的内容。 | 句子"long long ago"用“(long) \1”可以匹配“long long”，第一个小括号(long)匹配第一个，\1表示小括号匹配到的内容 |
| **(?:pattern)**                    | 仅仅是匹配内容和改变优先级，**不能通过反向引用捕获内容**     | –                                                            |
| **(?pattern) 或 (?'name'pattern)** | 给分组起一个名字，然后可以通过分组名称的反向引用捕获内容，如‘**\k**'，**在python中是使用(?Ppattern)进行分组** | 句子“long long ago”，可以用(?<tag>(long)?) \1或者(?<tag>(long)?) \k<tag>匹配“long long” |

#### 5、断言

| **正则表达式**   | **说明**                                            | **举例**                                                     |
| ---------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| **(?=pattern)**  | 表示断言**后面一定会出现**一个pattern能匹配的内容   | 单词“abcddeafaag”用‘a(?=bc)’匹配的结果是第一个‘a’字母。      |
| **(?<=pattern)** | 表示断言**前面一定会出现**一个pattern能匹配的内容   | 单词“abcddeafaag”用‘(?<=de)a’匹配的结果是第二个‘a’字母。     |
| **(?!pattern)**  | 表示断言**后面一定不能出现**一个pattern能匹配的内容 | 单词“abcddeafaag”用‘a(?!bc)’匹配的结果是最后几个‘a’字母。    |
| **(?!            | 表示断言**前面一定不能出现**一个pattern能匹配的内容 | 单词“abcddeafaag”用‘(?<!de)a’匹配的结果是第一个和最后一个‘a’字母。 |

####  6、非贪婪模式

| **正则表达式** | **说明 **                                              |
| -------------- | ------------------------------------------------------ |
| ***? **        | 表示前面的元字符可以重复任意次数，但尽可能的少重复     |
| **+? **        | 表示前面的元字符最少出现一次，但尽可能的少重复         |
| **?? **        | 表示前面的元字符最多出现一次，但尽可能的少重复         |
| **{n,}?**      | 表示前面的元字符必须出现n次以上，但尽可能的少重复      |
| **{n,m}?**     | 表示前面的元字符必须出现n次到m次之间，但尽可能的少重复 |

#### 7、引擎选项

| **代码**                 | **说明 **                                                    | **Python ** |
| ------------------------ | ------------------------------------------------------------ | ----------- |
| IgnoreCase               | 匹配时忽略大小写                                             | **re.I**    |
| SingleLine               | 单行模式：整个字符串作为一个处理单独，‘.’可以匹配所有字符，包括换行符 | **re.S**    |
| MultiLine                | 多行模式：每一行作为处理单位                                 | **re.M**    |
| IgnorePatternWhitespache | 忽略表达式中的空白字符                                       | **re.X**    |

#### 8、总结

  ① **1个元字符只是表示满足条件的1个字符**，可以配合次数控制元字符来重复多次。

  ② 如果想使用元字符本身的意思，可以**使用‘\’转义**，比如‘\\d’表示‘\d’本身，不再表示一个数字。

  ③ 次数控制字符**仅仅是重复前面一个字符或者元字符**，不是重复前面所有字符。

  ④ 使用pattern1|pattern2，这整个正则表达式的匹配结果是pattern1和pattern2分别匹配的结果之和。

  ⑤ 分组的作用：**匹配内容、改变优先级、反向引用**

  ⑥ 分组的分类：普通分组，使用**‘\数字’**获取相应分组的内容，命名分组，使用‘**\k**’获取相应分组的内容

  ⑦ 断言表达式一般是接在某个字符或者表达式的前面或者后面，**相当于一个判断条件，本身断言不占分组号，也不会匹配结果**。

  ⑧ **默认是贪婪模式**，也就是尽可能的匹配，只要在重复的符号后面**加一个‘?’，表示非贪婪**，就尽量的少匹配。

  ⑨ 单行模式：**把整个文本的内容作为一个长字符串**，^、$分别表示这整个字符串的开始和结尾，‘.’也可以匹配所有字符

  ⑩ 多行模式：**每一行作为处理单位**，^、$分别表示这行的开始和结尾，‘.’也匹配除了换行符之外的所有字符

#### 9、编写正则表达式的一般流程

  ① 使用**元字符和普通字符**把需要匹配的核心内容构造出一个表达式雏形。

  ② 再这个基础上，添加符合要求的**位置控制和次数控制**字符

  ③ 如果需要反向引用或者改变优先级，再**添加分组**

  ④ 最后再复杂的话，需要增加判断条件，再**使用断言**




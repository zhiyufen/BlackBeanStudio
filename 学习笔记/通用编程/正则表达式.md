## 正则表达式

本文笔记来源于《精通正则表达式（第三版本）》

最近打算写一个小功能，而这个小功能需要使用正则表达式来解析短信中我所需要的信息， 虽然之前也从网上看过正则表达式使用的文章，但都不是系统的，基本都是要用什么就查什么，然后就拿来用，而无法知道是否它的性能怎样，是否有更好的易用，性能又好的表达式，都不得而知。因此系统学一下，以后免得又是到时无头苍蝇一样去搜索；

### Egrep 元字符

Egrep 与grep一样是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来， 是Linux系统中常用的工具；

##### 行的起始和结束

在检查一行文本时， 使用脱字符 “^” 代表一行的开始；以美元符"$"代表一行的结束；

```xml
^cat$
```

##### 字符组

[...] 字符组，它容许使用者列出在某处期望匹配的字符；

比如： gr[ea]y  能匹配到 gray, grey; [ea] 表示能匹配e或者a即可；



在字符组里,有一个字符组元字符：  “-” 连字符表示一个范围： 比如 [0-9], [a-z]; 多重范围也是容许的，例如：[0123456789abcdefgABCDEFG] 可以表示成：[0-9a-gA-G]; 

注：只有在字符组内部，连字符才是元字符， 否则它就是只能匹配普通的连字符号；



##### 排除型字符组

用 "[^]" 取代 [...], 这个字符组就会匹配任何未列出的字符；

```
[^0-1] //匹配除了0到6以外的任何字符；
```

注： 排除型字符组表示“匹配一个未列出的字符”，而不是“不要匹配列出的字符”；这个表示就很好解释了下面不匹配的例子：

```java
q[^u]

Iraqi  //匹配
Iraqax //匹配
qoph   //匹配
Qoph   //不匹配
Iraq   //不匹配， q[^u]要求q之后紧跟一个u以外的字符(通常来说，结尾会有一个换行字符，但egrep在匹配正则表达式之前把这些换行符去掉，其它软件也是一样)
```

 

##### 用点号匹配任意字符

元字符“.” 是用来匹配任意字符的字符组的简便写法；

```java
03.19.76

03.19.76  //匹配
03/19/76  //匹配
03-19/76  //匹配
```

注: 点号在字符组里并不是元字符，只是单纯一个点号而，或者说元字符在字符组都不是元符号，只是本身表示的符号

#### 多选结构

##### 匹配任意子表达式

“|” 元符号，表示是“或”， 使用它，可以把不同的子表达式组合与一个总的表达式，而该总的表达式又能够匹配任意的子表达式；子表达式称为“多选分支”；

```java
Bob|Robert
grey|gray 或者 gr(e|a)y  // 等同于 gr[ea]y
//其中上面括号划定多选结构的范围的
```

##### 忽略大小写

egrep的命令行参数"-i"

```
egrep -i path build.gradle
```

##### 单词分界符

可使用“元字符序列”：  "\\<"  "\\>" 来匹配单词的开头和结束位置(有时egrep版本不支持)；

```java
\<cat/>

cat  //匹配
acat //不匹配
```

在Java中可以使用 “\\b” ；

小结：

| 元字符 | 名称         | 匹配对象                       |
| ------ | ------------ | ------------------------------ |
| .      | 点号         | 单个任意字符                   |
| [...]  | 字符组       | 列出的任意字符                 |
| [^...] | 排除型字符组 | 未列出的任意字符               |
| ^      | 脱字符       | 行的起始位置                   |
| $      | 美元符       | 行的结束位置                   |
| \\<    | 反斜线-小于  | 单词的起始位置                 |
| \\>    | 反斜线-大于  | 单词的结束位置                 |
| \|     | 竖线         | 匹配分隔两边的任意一个表达式   |
| (...)  | 括号         | 限制竖线的作用范围，及其它功能 |

-----

#### 可选项元素

元符号“？” 表示可选项，把它加在一个字符的后面，表示此处容许出现这个字符，但不是匹配成功的必要条件；

```java
colou?r //可以匹配 colour, color
4(th)?  //可以匹配  4, 4th;  ()里表示一个整体，而？跟在后面表示作用对象是“th”
```

##### 其它量词：重复出现

元字符 “+” 表示之前紧邻的元素出现一次或者多次；

元字符 “*” 表示之前紧邻的元素出现任意多次，或者不出现；

问号，加号，星号这3个元字符，统称量词，它们限定了所作用元素的匹配次数；

比如要匹配： <HR SIZE = 14> 这样的文件

```
<HR * SIZE *= *[0-9]+ *
```

注： 空格符也是普通字符之一；

小结：

|            | 次数下限 | 次数上次 | 含义                                         |
| ---------- | -------- | -------- | -------------------------------------------- |
| ？         | 无       | 1        | 可以不出现，也可以只出现一次(单次可选)       |
| *          | 无       | 无       | 可以出现无数次，也可以不出现（任意次数均可） |
| +          | 1        | 无       | 可以出现无数次，但至少要出现一次（至少一次） |
| {min, max} |          |          | 至少需要min次，至多容许max次                 |

------

##### 

##### 规定重现次数的范围：区间

**区间量词**定义重现次数的区间：“....{min, max}” ，表示容许的重现次数在 min 到 max 之间；

##### 括号及反向引用

在正则表达式中，括号能够“记住”它们包含的子表达式匹配的文本。 而反向引用 “\1”， “\2”， “\3” 等来表示第一，第二，第三组括号匹配的文本。

```java
([a-z])([0-9])\1\2  //\1代表匹配[a-z]内容， \2代表匹配[0-9]内容
```



#####  转义

使用 “\” + 元符号 可以转元符号转成普通的字符；

```
\.
\([a-z]\) // (a)
```

##### 更多例子：

```
[a-zA-Z_0-9][a-zA-Z_0-9]  //变量名
“[^"]*”  //引号内的字符串
\$[0-9]+(\.[0-9][0-9]?) //美元金额（可能包含小数）
\<http[s]?://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!~*%$]*\.html?\> //网站 url
(1[012]|[1-9]):[0-5][0-9] (am|pm) //12小时制的时刻
[01]?[0-9]|2[0-3]:[0-5][0-9]      //24小时制的时刻
```



Other:

```
\t  //制表符
\n  //换行符
\r  //回车符
\s  //匹配所有“空白”， 包括空格符，制表符，换行符和回车符。
\S  //除"\s"之外的任何字符
\w  //[a-zA-Z0-9]
\W  //除"\w"之外的任何字符
\d  //[0-9]， 即数字
\D  //除"\d"之外的任何字符
```

-----



#### Java中的正则处理

使用 Sun 提供的 java.util.regex包

```java
import java.util.regex.*

Pattern r = Pattern.compile("^Sujbecet: {.*}", RegexOptions.IgnoreCase);
Matcher m = r.matcher(line);
if (m.find()) {
    subject = m.group(1); //第一个括号内的子表达式匹配的文本；
}

//Or
if (!Pattern.matchers("\\s", line)) {
    //如果line不是空行
}

//有些Java对象自身整合了正则表达式的，比如String
if (!line.matchers("\\s")) {
    //...
}

```

注： 字符串中每个'\\' 都必须转义为 '\\\\', 比如 ‘\\w’ 必须写成 '\\\\w'; 

查找和替换，可使用 matcher类的 m.replaceAll("aaa") ; 

----

##### 表达式的匹配原理

Java属于 传统型的NFA(另外一个是DFA)；

两条普适的原则：

- 优先选择最左端 （最靠开头）的匹配结果；
- 标准的匹配量词（*、+、？ 和 {m,n}） 是匹配优先的。 

###### 规则1：优先选择最左端 （最靠开头）的匹配结果

概念：匹配先从需要查找的字符串的起始位置尝试匹配。如果在当前位置测试了所有的可能之后 不能找到匹配结果，就需要从字符串的第二个字符之前的位置开始重新尝试。在找到匹配结果前必须在所有的位置重复此过程。只有在尝试过所有的起始位置（直到字符串的最后一个字符）都不能找到匹配结果的情况下，才会报告匹配失败；

比如使用 fat|cat|belly|your 来匹配字符串 “The dragging belly indicates that your cat is too fat”;

第一个匹配结果是 belly 而不是 fat; 

##### 规则2：标准的匹配量词（*、+、？ 和 {m,n}） 是匹配优先的

用这些量词来约束某个表达式，在匹配成功之前，进行尝试的次数是存在上限和下限的。 而规则2表明，这些尝试总是希望获得最长的匹配；

简单来说，标准匹配量词的结果“可能” 并非所有可能中最长的，但它们总是尝试匹配尽可能多的字符，直到匹配上限为止。 

比如我们使用 “\b\w+s\b” 来匹配包含 ‘s’ 的字符串，如：“regexes” ; 

'\w+' 会尽可能匹配多的字符，那么刚开始会匹配整个“regexes”, 再去匹配 's' 就无法匹配；

但由于's'是必须匹配的字符， 那么就要要求逐一把字符串一个个吐出来，先释放出来一个 's';  那么后面正则表达式 's\b' 就匹配成功了；如果不行，还要释放更多的字符；所以‘\w+’ 只匹配到了“regexe”；

JAVA 是NFA型的， 它的原理是回溯机制；

在回溯过来中，有一个重要原则：

- 如果需要在“进行尝试” 和 “跳过尝试” 之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”， 而对于忽略优先量词（??, *?, +?），会选择“跳过尝试” 。 
- 距离当前最近储存的选项就是当本地失败强制回溯时使用的原则是LIFO(后进先出)。

占有优先量词： ?+, *+, ++, {m,n}+ 与匹配优先量词很相似，只是它们从来不交还已经匹配的字符.

量词种类意义: 

贪婪	勉强	侵占
X?		X??		X?+		  匹配 X 零次或一次
X*		X*?		X*+		     匹配 X 零次或多次
X+		X+?		X++		匹配 X 一次或多次
X{n}	X{n}?	X{n}+	   匹配 X n 次
X{n,}	X{n,}?	X{n,}+	匹配 X 至少 n 次
X{n,m}	X{n,m}?	X{n,m}+	匹配 X 至少 n 次，但不多于 m 次

在贪婪、勉强和侵占三个量词间有着细微的不同。


贪婪量词之所以称之为"贪婪的"，是由于它们强迫匹配器读入(或者称之为吃掉)整个输入的字符串，来优先尝试第一次匹配，如果第一次尝试匹配（对整个输入的字符串）失败，匹配器会通过回退整个字符串的一个字符再一次进行尝试，不断的进行处理直到找到一个匹配，或者左边没有更多的字符用来回退了。赖于在表达式中使用的量词，最终它将尝试地靠着1或0个字符的匹配。

但是，勉强量词采用相反的路径：从输入字符串的开始处开始，因此每次勉强地吞噬一个字符来寻找匹配，最终它们尝试整个输入的字符串。



更详细原理和例子，还请看书了，原理嘛， 理解了就好， 这里就不作详细笔记了。



### Java

